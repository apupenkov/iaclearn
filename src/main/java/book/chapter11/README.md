# КОЛЛЕКЦИИ И STREAM API
Вопросы:
- [1. Назвать основные интерфейсы коллекций. Какие бывают коллекции?](#назвать-основные-интерфейсы-коллекций-какие-бывают-коллекции)
- [2. В чем особенности разных видов коллекций? Когда и какие коллекции следует применять?](#в-чем-особенности-разных-видов-коллекций-когда-и-какие-коллекции-следует-применять)
- [3. Сравнить ArrayList и LinkedList.](#сравнить-arraylist-и-linkedlist)
- [4. Сравнить HashMap и Hashtable.](#сравнить-hashmap-и-hashtable)
- [5. Как устроены HashSet, TreeMap, TreeSet.](#как-устроены-hashset-treemap-treeset)
- [6. Принцип работы и реализации HashMap. Изменения HashMap в java 8.](#принцип-работы-и-реализации-hashmap-изменения-hashmap-в-java-8)
- [7. Чем отличается ArrayList от Vector?](#чем-отличается-arraylist-от-vector)
- [8. Особенности интерфейса Set.](#особенности-интерфейса-set)
- [9. Как добавляются объекты в HashSet?](#как-добавляются-объекты-в-hashset)
- [10. Какими способами можно отсортировать коллекцию? Привести три способа.](#какими-способами-можно-отсортировать-коллекцию-привести-три-способа)
- [11. Как правильно удалить элемент из коллекции при итерации в цикле?](#как-правильно-удалить-элемент-из-коллекции-при-итерации-в-цикле)
- [12. Как правильно удалить элемент из ArrayList (или другой коллекции) при поиске этого элемента в цикле?](#как-правильно-удалить-элемент-из-arraylist-или-другой-коллекции-при-поиске-этого-элемента-в-цикле)
- [13. Коллекции из пакета java.util.concurrent. Их особенности.](#коллекции-из-пакета-javautilconcurrent-их-особенности)
- [14. Что происходит при добавлении в ArrayList нового элемента и как это реализовано?](#что-происходит-при-добавлении-в-arraylist-нового-элемента-и-как-это-реализовано)
- [15. Метод для преобразования потоконебезопасной коллекции в потокобезопасную.](#метод-для-преобразования-потоконебезопасной-коллекции-в-потокобезопасную)
- [16. Написать метод, в котором проверяется HashMap на наличие в нем некоторого значения, и его извлечения, если такого значения нет, надо добавить значение с пустой строкой и ее вернуть. Написать код, чтобы он был как можно более эффективным.](#написать-метод-в-котором-проверяется-hashmap-на-наличие-в-нем-некоторого-значения-и-его-извлечения-если-такого-значения-нет-надо-добавить-значение-с-пустой-строкой-и-ее-вернуть-написать-код-чтобы-он-был-как-можно-более-эффективным)
- [17. Какие коллекции более «быстрые» — legacy (Vector, Hashtable) или из пакета java.util.concurrent?](#какие-коллекции-более-быстрые--legacy-vector-hashtable-или-из-пакета-javautilconcurrent)
- [18. Если в коллекцию часто добавлять элементы и удалять, какую лучше использовать? Почему? Как они устроены?](#если-в-коллекцию-часто-добавлять-элементы-и-удалять-какую-лучше-использовать-почему-как-они-устроены)
- [19. Как быстро получить копию коллекции? Записать код преобразования.](#как-быстро-получить-копию-коллекции-записать-код-преобразования)
- [20. Чем Stream отличается от коллекции?](#чем-stream-отличается-от-коллекции)
- [21. Промежуточные и терминальные операции в stream.](#промежуточные-и-терминальные-операции-в-stream)
- [22. Методы: map() vs flatMap() в stream.](#методы-map-vs-flatmap-в-stream)
- [23. Что такое потоковая обработка данных?](#что-такое-потоковая-обработка-данных)

## Назвать основные интерфейсы коллекций. Какие бывают коллекции?
Основные интерфейсы коллекций в Java это:

1. **Collection**: Этот интерфейс является корневым для всех других интерфейсов коллекций. Он определяет базовые операции, которые доступны для всех коллекций, такие как добавление, удаление, проверка на наличие элемента и т.д.

2. **List**: Этот интерфейс представляет упорядоченные коллекции, которые могут содержать дублирующиеся элементы. Примеры реализаций: `ArrayList`, `LinkedList`, `Vector`.

3. **Set**: Этот интерфейс представляет коллекции, которые не могут содержать дублирующиеся элементы. Примеры реализаций: `HashSet`, `LinkedHashSet`, `TreeSet`.

4. **Queue**: Этот интерфейс представляет коллекции, которые работают по принципу "первым пришёл — первым ушёл" (FIFO) или "первым пришёл — последним ушёл" (LIFO). Примеры реализаций: `LinkedList`, `PriorityQueue`.

5. **Deque**: Этот интерфейс представляет двухсторонние очереди, где элементы могут добавляться и извлекаться с обоих концов. Примеры реализаций: `LinkedList`, `ArrayDeque`.

6. **Map**: Этот интерфейс представляет коллекции, хранящие пары ключ-значение, где каждый ключ связан с одним значением. Примеры реализаций: `HashMap`, `LinkedHashMap`, `TreeMap`.

Типы коллекций в Java:

- **List**: Список упорядоченных элементов с возможностью дублирования.
- **Set**: Множество уникальных элементов без дублирования.
- **Queue**: Очередь с предопределённым порядком извлечения элементов.
- **Deque**: Двухсторонняя очередь.
- **Map**: Сопоставление ключей с их значениями.
- **SortedSet**: Множество с сортировкой элементов.
- **NavigableSet**: Множество с дополнительными навигационными возможностями.
- **SortedMap**: Сопоставление с сортировкой ключей.
- **NavigableMap**: Сопоставление с дополнительными навигационными возможностями.

В Java также существуют различные реализации этих интерфейсов, каждая из которых имеет свои особенности и применение в различных сценариях.

[к оглавлению](#коллекции-и-stream-api)

## В чем особенности разных видов коллекций? Когда и какие коллекции следует применять?
Разные виды коллекций имеют различные особенности и предназначены для разных задач. Вот краткое описание особенностей и сценариев применения разных видов коллекций:

1. **List**:
    - Упорядоченные коллекции с возможностью дублирования элементов.
    - Применяются, когда необходимо хранить элементы в определенном порядке и допускаются повторения элементов.
    - `ArrayList` - хорош для случаев, когда операции чтения чаще операций записи.
    - `LinkedList` - удобен для операций вставки/удаления элементов.

2. **Set**:
    - Коллекции, которые хранят только уникальные элементы.
    - Применяются, когда необходимо убедиться, что элементы не дублируются.
    - `HashSet` - быстрый доступ к элементам.
    - `TreeSet` - элементы хранятся в отсортированном порядке.

3. **Queue** и **Deque**:
    - Коллекции для организации и управления порядком элементов.
    - Применяются, когда требуется поддерживать определенный порядок элементов.
    - `LinkedList` часто используется для реализации очередей и двухсторонних очередей.

4. **Map**:
    - Коллекции, хранящие пары ключ-значение.
    - Применяются, когда необходимо быстро находить значение по ключу.
    - `HashMap` - общая реализация, быстрый доступ.
    - `LinkedHashMap` - сохраняет порядок добавления элементов.
    - `TreeMap` - хранит элементы в отсортированном порядке.

Общие рекомендации:

- Выбор коллекции зависит от требований к операциям, которые будут выполняться чаще всего.
- Если нужно быстро искать элементы по ключу, используйте `HashMap` или `HashSet`.
- Если нужно хранить элементы в определенном порядке, используйте `LinkedHashMap`, `TreeMap` или `LinkedHashSet`.
- Для больших коллекций с частыми операциями вставки/удаления элементов, `ArrayList` может быть менее эффективным.
- При выборе коллекции учтите потребности в потокобезопасности: если коллекция будет использоваться в многопоточной среде, учтите это при выборе соответствующей реализации коллекции или синхронизации доступа к ней.

Выбор подходящей коллекции зависит от конкретной задачи и требований к производительности, потребляемой памяти и потокобезопасности.

[к оглавлению](#коллекции-и-stream-api)

## Сравнить ArrayList и LinkedList.
`ArrayList` и `LinkedList` - это две разные реализации интерфейса `List` в Java, и у них есть свои отличия и сильные стороны в зависимости от конкретной задачи. Вот сравнение `ArrayList` и `LinkedList` по разным аспектам:

**1. Способ хранения данных:**
- `ArrayList` использует динамический массив для хранения элементов.
- `LinkedList` использует двусвязный список, где каждый элемент ссылается на предыдущий и следующий.

**2. Вставка и удаление:**
- Вставка и удаление элементов в середине списка более эффективны для `LinkedList`, так как не требуется сдвигать другие элементы.
- Вставка и удаление в конце списка быстрее для `ArrayList`, так как не требуется перестраивать связи между элементами.

**3. Доступ по индексу:**
- Доступ к элементу по индексу быстрее для `ArrayList`, так как массив обеспечивает постоянное расположение элементов в памяти.
- Для `LinkedList` требуется пройти через список от начала или конца для доступа к элементу по индексу.

**4. Память:**
- `ArrayList` может использовать больше памяти, так как выделяет дополнительное пространство для потенциальных элементов.
- `LinkedList` может использовать больше памяти из-за дополнительных указателей на предыдущий и следующий элементы.

**5. Итерация:**
- Итерация (перебор) всех элементов `ArrayList` быстрее, чем `LinkedList`, из-за непрерывного расположения в памяти.

**6. Использование:**
- Если операции вставки и удаления элементов происходят редко, а часто используется доступ по индексу, то `ArrayList` может быть эффективнее.
- Если операции вставки и удаления элементов частые, особенно в середине списка, или требуется поддержка двунаправленных итераций, то `LinkedList` может быть предпочтительнее.

Выбор между `ArrayList` и `LinkedList` зависит от конкретных требований вашей задачи и ситуации.

[к оглавлению](#коллекции-и-stream-api)

## Сравнить HashMap и Hashtable.
`HashMap` и `Hashtable` - это две разные реализации интерфейса `Map` в Java. Они предоставляют ассоциативные массивы, где данные хранятся в виде пар "ключ-значение". Вот сравнение `HashMap` и `Hashtable` по разным аспектам:

**1. Синхронизация:**
- `Hashtable` является синхронизированной структурой данных, что делает его потокобезопасным для использования в многопоточных средах.
- `HashMap` не является синхронизированным, поэтому он более подходит для однопоточных сценариев. Для многопоточной работы с `HashMap` требуется внешняя синхронизация.

**2. Null-ключи и null-значения:**
- `Hashtable` не разрешает использование `null` в качестве ключа или значения.
- `HashMap` может использовать `null` в качестве ключа и значения.

**3. Производительность:**
- Из-за синхронизации, `Hashtable` может иметь худшую производительность в многопоточных сценариях.
- `HashMap` в однопоточных сценариях может иметь лучшую производительность из-за отсутствия накладных расходов на синхронизацию.

**4. Наследование от `Dictionary`:**
- `Hashtable` наследуется от устаревшего класса `Dictionary`.
- `HashMap` не наследуется от `Dictionary`.

**5. Итерация:**
- Итерация (перебор) элементов `Hashtable` менее эффективна из-за синхронизации.
- Итерация по `HashMap` более эффективна в однопоточных сценариях.

**6. Размер и производительность:**
- В большинстве случаев `HashMap` более предпочтителен из-за отсутствия синхронизации и более высокой производительности.

В общем случае, если вам не требуется синхронизации и вы работаете в однопоточной среде, `HashMap` является более предпочтительным выбором. Если вам нужна синхронизация или вы работаете в многопоточной среде, вы можете использовать `Hashtable`. Однако для современных многопоточных приложений `ConcurrentHashMap` часто является более эффективной альтернативой `Hashtable`.

[к оглавлению](#коллекции-и-stream-api)

## Как устроены HashSet, TreeMap, TreeSet.
`HashSet`, `TreeMap` и `TreeSet` - это реализации коллекций в Java, которые предоставляют особые возможности для хранения и организации элементов. Вот как они устроены:

1. **HashSet:**
    - `HashSet` реализует интерфейс `Set` и использует хэш-таблицу для хранения уникальных элементов.
    - При добавлении элемента в `HashSet`, вычисляется хэш-код элемента, и элемент вставляется в соответствующий ячейку хэш-таблицы.
    - Дубликаты не допускаются: если элемент с таким же хэш-кодом уже присутствует, он сравнивается на равенство с существующими элементами.

2. **TreeMap:**
    - `TreeMap` реализует интерфейс `SortedMap` и использует красно-черное дерево для хранения пар "ключ-значение".
    - Элементы в `TreeMap` хранятся в отсортированном порядке на основе ключей.
    - `TreeMap` гарантирует логарифмическую сложность операций поиска, вставки и удаления элементов.

3. **TreeSet:**
    - `TreeSet` реализует интерфейс `SortedSet` и использует красно-черное дерево для хранения уникальных элементов.
    - Элементы в `TreeSet` хранятся в отсортированном порядке.
    - Как и в `TreeMap`, `TreeSet` гарантирует логарифмическую сложность операций поиска, вставки и удаления элементов.

Общий механизм, используемый в `TreeMap` и `TreeSet`, позволяет эффективно поддерживать порядок элементов. Важно помнить, что для сравнения и сортировки элементов, хранящихся в `TreeMap` и `TreeSet`, используется либо компаратор, заданный при создании, либо сравнимость элементов (если они реализуют интерфейс `Comparable`).

[к оглавлению](#коллекции-и-stream-api)

## Принцип работы и реализации HashMap. Изменения HashMap в java 8.
`HashMap` - это реализация интерфейса `Map` в Java, представляющая собой хэш-таблицу, которая позволяет хранить пары ключ-значение. Принцип работы и реализация `HashMap` в Java:

1. **Хэш-функция и хэш-код:**
   - При добавлении пары ключ-значение в `HashMap`, ключу вычисляется хэш-код с помощью хэш-функции. Этот хэш-код определяет индекс внутреннего массива (бакета), куда будет помещена пара.

2. **Разрешение коллизий:**
   - В случае коллизии, когда два ключа имеют одинаковый хэш-код, они будут помещены в один и тот же бакет.
   - Для разрешения коллизий используется список связанных элементов (цепочка) внутри бакета. В Java 8 и выше, если в одном бакете накапливается много элементов, цепочка заменяется на бинарное дерево, что улучшает производительность в случае больших коллизий.

3. **Изменения в Java 8:**
   - В Java 8 введена оптимизация для `HashMap`, известная как "утонченные хэш-коды" (hashed values). Это позволяет избегать ряда накладных расходов при сравнении ключей, особенно в больших таблицах.
   - Введено понятие "порога переполнения" (load factor threshold). Это значение указывает, при каком проценте заполнения бакета таблицы размер хэш-таблицы будет увеличен. Это позволяет уменьшить вероятность коллизий.
   - В случае, если цепочка элементов в одном бакете становится слишком большой, эта цепочка будет заменена на бинарное дерево (авл-дерево), чтобы улучшить производительность при поиске.

Реализация `HashMap` в Java включает в себя управление размером, разрешение коллизий и поддержку операций вставки, поиска и удаления среди пар ключ-значение.

[к оглавлению](#коллекции-и-stream-api)

## Чем отличается ArrayList от Vector?
`ArrayList` и `Vector` являются двумя реализациями интерфейса `List` в Java и оба представляют динамические массивы. Однако у них есть несколько ключевых отличий:

1. **Синхронизация:**
   - `ArrayList` не синхронизирован по умолчанию. Это означает, что он не является потокобезопасным, и если необходимо обеспечить потокобезопасность, нужно обеспечивать её самостоятельно.
   - `Vector`, с другой стороны, синхронизирован. Все его методы синхронизированы, что делает его потокобезопасным. Однако это может вызывать лишние накладные расходы в случае, если потокобезопасность не требуется.

2. **Производительность:**
   - Из-за отсутствия синхронизации `ArrayList` обычно более быстрый по сравнению с `Vector`.

3. **Использование:**
   - В большинстве сценариев использования `ArrayList` предпочтительнее, так как потокобезопасность обычно может быть обеспечена более эффективными способами.
   - `Vector` может быть полезен, если требуется потокобезопасность, но не хочется реализовывать её самостоятельно.

4. **Итераторы:**
   - Оба класса предоставляют итераторы для обхода элементов, но из-за синхронизации `Vector` может вызывать проблемы при одновременных обходах в разных потоках.

5. **Увеличение размера:**
   - `ArrayList` увеличивает свой размер на 50% от текущего размера при его увеличении, в то время как `Vector` удваивает свой размер. Это может повлиять на оптимизацию использования памяти.

В целом, если нет специфических потребностей в потокобезопасности, `ArrayList` чаще используется из-за более высокой производительности.

[к оглавлению](#коллекции-и-stream-api)

## Особенности интерфейса Set.
Интерфейс `Set` является частью Java Collections Framework и представляет собой коллекцию, которая не может содержать дублирующихся элементов. Основные особенности интерфейса `Set` включают:

1. **Уникальность элементов:** Каждый элемент в `Set` может быть представлен только один раз. Если попытаться добавить дублирующийся элемент, операция добавления не выполнится, и `Set` останется неизменным.

2. **Отсутствие порядка:** Элементы в `Set` не имеют определенного порядка. Например, порядок элементов в `HashSet` может не совпадать с порядком их добавления.

3. **Методы проверки наличия элемента:** `Set` предоставляет методы для проверки наличия элемента в коллекции (`contains`) и определения пуста ли коллекция (`isEmpty`).

4. **Методы для операций с другими множествами:** `Set` поддерживает операции над множествами, такие как пересечение, объединение и разность элементов. Эти операции обеспечиваются методами, такими как `retainAll`, `addAll` и `removeAll`.

5. **Итерирование:** `Set` можно перебирать с помощью итератора или цикла for-each.

6. **Null:** `Set` может содержать только один `null` элемент, так как дублирующиеся элементы не допускаются.

7. **Реализации:** В Java есть несколько реализаций интерфейса `Set`, включая `HashSet`, `LinkedHashSet` и `TreeSet`. Каждая реализация имеет свои особенности, такие как порядок элементов и скорость операций.

Интерфейс `Set` часто используется для представления коллекций уникальных элементов, где порядок не важен и необходимо быстро проверять наличие элементов.
[к оглавлению](#коллекции-и-stream-api)

## Как добавляются объекты в HashSet?
Объекты добавляются в `HashSet` с помощью метода `add()`. При добавлении объекта в `HashSet` происходят следующие шаги:

1. Хэш-код вычисления: Каждый объект вызывает свой метод `hashCode()`, чтобы вычислить хэш-код. Хэш-код используется для определения "корзины" (bucket), в которую объект будет добавлен.

2. Определение корзины: Хэш-код объекта преобразуется в индекс массива, определяющий, в какую корзину (bucket) объект будет добавлен.

3. Проверка наличия элемента: Внутри корзины выполняется проверка на наличие объекта с таким же хэш-кодом. Если такой объект уже существует (имеется коллизия), то выполняется дополнительная проверка на равенство существующего объекта и добавляемого объекта с помощью метода `equals()`. Если объекты равны, добавление не выполняется.

4. Добавление в корзину: Если элемент не найден или не равен уже существующему элементу, он добавляется в корзину.

5. Расширение хэш-таблицы: Если количество элементов в корзинах становится слишком большим, `HashSet` автоматически увеличивает размер хэш-таблицы (рехэширование), чтобы уменьшить вероятность коллизий и поддерживать эффективность.

Важно отметить, что для корректной работы хэш-код объектов должен быть стабильным во время жизни объекта. Также, если переопределяется метод `equals()`, то обязательно должен быть переопределен и метод `hashCode()`, чтобы соблюдать контракт между этими методами.

`HashSet` использует хэш-таблицу для хранения элементов, что обеспечивает почти постоянное время выполнения для операций добавления, удаления и поиска элементов.

[к оглавлению](#коллекции-и-stream-api)

## Какими способами можно отсортировать коллекцию? Привести три способа.
Вы можете отсортировать коллекцию в Java несколькими способами:

1. **Использование метода `Collections.sort()`**: Это статический метод класса `Collections`, который позволяет отсортировать любую коллекцию, реализующую интерфейс `List`, с помощью алгоритма сортировки, который использует методы `compareTo()` элементов.

   Пример:
   ```java
   List<Integer> numbers = new ArrayList<>();
   numbers.add(3);
   numbers.add(1);
   numbers.add(2);
   Collections.sort(numbers);
   ```

2. **Использование метода `sort()` из Stream API**: Если у вас есть `Collection`, вы можете вызвать метод `stream()` для создания потока элементов и затем использовать метод `sorted()` для сортировки элементов.

   Пример:
   ```java
   List<Integer> numbers = Arrays.asList(3, 1, 2);
   List<Integer> sortedNumbers = numbers.stream()
                                        .sorted()
                                        .collect(Collectors.toList());
   ```

3. **Использование компаратора**: Вы можете создать собственный класс, реализующий интерфейс `Comparator`, чтобы определить свой порядок сортировки. Затем вы можете передать этот компаратор методу `sort()` или `Collections.sort()`.

   Пример:
   ```java
   List<String> names = Arrays.asList("Alice", "Bob", "Charlie");
   Collections.sort(names, (name1, name2) -> name1.length() - name2.length());
   ```

Это лишь несколько способов сортировки коллекций в Java. Выбор метода зависит от ваших потребностей и структуры данных.

[к оглавлению](#коллекции-и-stream-api)

## Как правильно удалить элемент из коллекции при итерации в цикле?
Правильное удаление элемента из коллекции при итерации в цикле требует особого внимания, чтобы избежать ошибок. Во многих случаях можно использовать итератор для безопасного удаления элементов. Вот как это делается:

```java
List<Integer> numbers = new ArrayList<>();
numbers.add(3);
numbers.add(1);
numbers.add(2);

Iterator<Integer> iterator = numbers.iterator();
while (iterator.hasNext()) {
    int number = iterator.next();
    if (number == 2) {
        iterator.remove();  // Безопасное удаление элемента
    }
}
```

Использование `iterator.remove()` обеспечивает правильное удаление элемента из коллекции. Это позволяет избежать проблем с изменением структуры коллекции во время итерации.

Если вы используете цикл `for-each`, то нельзя использовать `remove()` внутри цикла, так как это может вызвать исключение `ConcurrentModificationException`. В этом случае, вы можете использовать итератор:

```java
List<Integer> numbers = new ArrayList<>();
numbers.add(3);
numbers.add(1);
numbers.add(2);

Iterator<Integer> iterator = numbers.iterator();
while (iterator.hasNext()) {
    int number = iterator.next();
    if (number == 2) {
        iterator.remove();  // Безопасное удаление элемента
    }
}
```

Важно помнить, что при использовании итератора, вы можете безопасно удалять элементы из коллекции во время итерации. Это позволит избежать ошибок и проблем синхронизации.

[к оглавлению](#коллекции-и-stream-api)

## Как правильно удалить элемент из ArrayList (или другой коллекции) при поиске этого элемента в цикле?
Если вы хотите удалить элемент из `ArrayList` (или другой коллекции) при его поиске в цикле, вы можете воспользоваться следующим методом:

```java
List<Integer> numbers = new ArrayList<>();
numbers.add(3);
numbers.add(1);
numbers.add(2);

int elementToRemove = 2;

for (int i = 0; i < numbers.size(); i++) {
    if (numbers.get(i) == elementToRemove) {
        numbers.remove(i);
        i--; // Сдвигаемся на одну позицию назад после удаления
    }
}
```

Важно помнить, что при удалении элемента из `ArrayList`, индексы всех следующих элементов смещаются на одну позицию влево. Поэтому после удаления элемента, индекс `i` должен быть уменьшен на единицу, чтобы следующая итерация цикла обработала элемент, который сместился на его место.

Однако этот метод может иметь проблемы с производительностью при удалении нескольких элементов, так как операция `remove()` для `ArrayList` сдвигает все последующие элементы. Если вам часто требуется удалять элементы из середины списка, то использование `LinkedList` может быть более эффективным.

Если вы используете Java 8 и выше, вы также можете использовать метод `removeIf()` для удобного удаления элементов на основе условия:

```java
List<Integer> numbers = new ArrayList<>();
numbers.add(3);
numbers.add(1);
numbers.add(2);

int elementToRemove = 2;

numbers.removeIf(number -> number == elementToRemove);
```

Этот метод позволяет передать лямбда-выражение, которое определяет условие для удаления элементов.

[к оглавлению](#коллекции-и-stream-api)

## Коллекции из пакета java.util.concurrent. Их особенности.
Пакет `java.util.concurrent` предоставляет набор классов и интерфейсов для работы с многопоточным программированием и параллельными вычислениями. Эти классы и интерфейсы предоставляют более эффективные и безопасные альтернативы для работы с многопоточностью по сравнению с традиционными коллекциями из пакета `java.util`.

Некоторые из основных коллекций и классов, предоставляемых пакетом `java.util.concurrent`, включают:

1. `ConcurrentHashMap`: Это многопоточная реализация `HashMap`, предназначенная для параллельных операций чтения и записи. Она обеспечивает высокую производительность при одновременном доступе нескольких потоков.

2. `ConcurrentLinkedQueue`: Это многопоточная реализация очереди, которая предоставляет эффективные операции добавления и удаления элементов, подходящая для использования в многопоточных сценариях.

3. `BlockingQueue`: Это интерфейс, определяющий очередь с блокировкой, который поддерживает методы блокирования потоков до тех пор, пока очередь не станет доступной для добавления или удаления элементов.

4. `ConcurrentSkipListMap` и `ConcurrentSkipListSet`: Это реализации `SortedMap` и `SortedSet`, использующие структуру данных "skip list" для обеспечения высокой производительности при многопоточных операциях.

5. `CountDownLatch`: Этот класс предоставляет механизм ожидания выполнения определенного количества операций, прежде чем продолжится выполнение потока.

6. `CyclicBarrier`: Этот класс предоставляет механизм синхронизации нескольких потоков, ожидающих достижения определенной точки в коде.

7. `Semaphore`: Этот класс предоставляет семафор для ограничения доступа к ресурсам определенным количеством потоков.

8. `Executor` и `ExecutorService`: Эти интерфейсы предоставляют абстракцию для выполнения асинхронных задач и управления пулами потоков.

Коллекции и классы из пакета `java.util.concurrent` разработаны с учетом потребностей многопоточных приложений и обеспечивают эффективное использование ресурсов и безопасную многопоточную работу.

[к оглавлению](#коллекции-и-stream-api)

## Что происходит при добавлении в ArrayList нового элемента и как это реализовано?
При добавлении нового элемента в `ArrayList` происходит следующее:

1. **Проверка размера**: Сначала проверяется, достаточно ли у `ArrayList` свободного места для добавления нового элемента. Если нет, то выполняется увеличение внутреннего массива.

2. **Добавление элемента в массив**: Новый элемент добавляется в массив на следующую доступную позицию. Размер массива увеличивается, если это необходимо.

3. **Увеличение размера массива**: Если внутренний массив `ArrayList` заполнился, то создается новый массив большего размера (обычно увеличивается в два раза или по какому-то другому коэффициенту) и все элементы из старого массива копируются в новый. Это может быть относительно дорогой операцией, так как требует времени и памяти для копирования.

4. **Увеличение `size`**: После успешного добавления элемента, значение переменной `size` (количество элементов в списке) увеличивается на 1.

Реализация `ArrayList` представляет собой массив с динамически изменяющимся размером. Когда массив заполняется, создается новый массив большего размера, а элементы из старого массива копируются в новый. Это может вызывать дополнительные затраты на память и время, особенно при добавлении большого количества элементов. Однако `ArrayList` хорошо подходит для случаев, когда требуется быстрый доступ к элементам по индексу и периодическое добавление/удаление элементов.

При работе с большими объемами данных, когда часто происходит добавление элементов, рассмотрение других структур данных, таких как `LinkedList` или `java.util.concurrent` коллекции, может быть более эффективным с точки зрения производительности.

[к оглавлению](#коллекции-и-stream-api)

## Метод для преобразования потоконебезопасной коллекции в потокобезопасную.
Для преобразования потоконебезопасной коллекции в потокобезопасную можно использовать статический метод `Collections.synchronizedCollection()` из класса `java.util.Collections`. Этот метод принимает на вход коллекцию и возвращает ее потокобезопасную обертку.

Вот пример использования этого метода:

```java
import java.util.*;

public class SynchronizedCollectionExample {
    public static void main(String[] args) {
        // Создание потоконебезопасной коллекции ArrayList
        List<String> unsynchronizedList = new ArrayList<>();
        unsynchronizedList.add("one");
        unsynchronizedList.add("two");
        unsynchronizedList.add("three");

        // Преобразование в потокобезопасную коллекцию
        Collection<String> synchronizedCollection = Collections.synchronizedCollection(unsynchronizedList);

        // Теперь synchronizedCollection является потокобезопасной оберткой для unsynchronizedList
    }
}
```

Важно понимать, что использование потокобезопасных коллекций не всегда является оптимальным решением, так как они могут приводить к проблемам производительности в многопоточных средах. В некоторых случаях более эффективным подходом может быть использование коллекций из пакета `java.util.concurrent`, которые спроектированы для обеспечения высокой производительности и безопасности в многопоточных приложениях.

[к оглавлению](#коллекции-и-stream-api)

## Написать метод, в котором проверяется HashMap на наличие в нем некоторого значения, и его извлечения, если такого значения нет, надо добавить значение с пустой строкой и ее вернуть. Написать код, чтобы он был как можно более эффективным.
Пример метода, который выполняет описанную вами операцию, может выглядеть так:

```java
import java.util.HashMap;
import java.util.Map;

public class HashMapExample {
    public static void main(String[] args) {
        Map<String, String> hashMap = new HashMap<>();
        // Предполагаем, что hashMap уже содержит некоторые данные

        String key = "someKey";
        String value = getOrCreateValue(hashMap, key);
        System.out.println("Value for key " + key + ": " + value);
    }

    public static String getOrCreateValue(Map<String, String> hashMap, String key) {
        // Попытка получить значение по ключу
        String value = hashMap.get(key);

        // Если значение отсутствует, добавляем пустую строку и возвращаем ее
        if (value == null) {
            hashMap.put(key, "");
            return "";
        }

        // Если значение найдено, возвращаем его
        return value;
    }
}
```

Этот метод проверяет наличие значения по ключу в HashMap. Если значение не найдено, добавляет пустую строку и возвращает ее. Если значение уже существует, оно просто возвращается.

[к оглавлению](#коллекции-и-stream-api)

## Какие коллекции более «быстрые» — legacy (Vector, Hashtable) или из пакета java.util.concurrent?
Коллекции из пакета `java.util.concurrent` (например, `ConcurrentHashMap`, `ConcurrentLinkedQueue`, `CopyOnWriteArrayList` и другие) предназначены для обеспечения многопоточной безопасности и эффективной работы в параллельных средах. Они предоставляют различные механизмы синхронизации и оптимизированы для работы в многопоточных приложениях.

С другой стороны, такие legacy коллекции, как `Vector` и `Hashtable`, были введены в Java до внедрения пакета `java.util.concurrent` и предоставляют базовые механизмы синхронизации для многопоточного доступа. Однако они не всегда эффективно масштабируются в условиях высокой нагрузки и множества потоков из-за более грубых методов синхронизации.

Коллекции из пакета `java.util.concurrent` предоставляют более гибкие и эффективные механизмы синхронизации для многопоточного доступа и, следовательно, могут считаться более "быстрыми" и приспособленными к современным многозадачным приложениям.

[к оглавлению](#коллекции-и-stream-api)

## Если в коллекцию часто добавлять элементы и удалять, какую лучше использовать? Почему? Как они устроены?
Если вам часто приходится добавлять и удалять элементы из коллекции, то рекомендуется использовать `LinkedList`.

Причина в том, что `LinkedList` реализована как двусвязный список, и вставка и удаление элементов в середине списка или на его концах происходит сравнительно быстро за константное время O(1). Однако доступ к элементам по индексу медленнее, чем у `ArrayList`, так как для получения элемента по индексу нужно пройти по списку с начала или с конца.

С другой стороны, если вы чаще обращаетесь к элементам по индексу и проводите мало операций вставки/удаления, `ArrayList` может быть более эффективным, так как доступ к элементам по индексу в `ArrayList` выполняется за константное время O(1), а не O(n) как у `LinkedList`.

Итак, выбор между `ArrayList` и `LinkedList` зависит от того, какие операции (добавление, удаление, доступ по индексу) преобладают в вашем конкретном случае использования коллекции.

[к оглавлению](#коллекции-и-stream-api)

## Как быстро получить копию коллекции? Записать код преобразования.
Для получения копии коллекции в Java можно воспользоваться конструкторами коллекций, которые принимают другую коллекцию в качестве аргумента. Например, для `ArrayList`:

```java
import java.util.ArrayList;
import java.util.List;

public class Main {
    public static void main(String[] args) {
        List<String> originalList = new ArrayList<>();
        originalList.add("Item 1");
        originalList.add("Item 2");
        originalList.add("Item 3");

        List<String> copyList = new ArrayList<>(originalList);

        System.out.println("Original List: " + originalList);
        System.out.println("Copy List: " + copyList);
    }
}
```

Для других коллекций, таких как `LinkedList`, `HashSet`, `TreeSet` и так далее, также можно использовать аналогичный подход, создавая новую коллекцию и передавая в неё существующую коллекцию в конструкторе.

[к оглавлению](#коллекции-и-stream-api)

## Чем Stream отличается от коллекции?
`Stream` в Java - это абстракция, которая позволяет выполнять операции над набором элементов данных. Основное отличие `Stream` от коллекции заключается в том, что `Stream` не является структурой данных, а скорее представляет собой поток данных, который можно преобразовывать и обрабатывать с использованием различных операций.

Вот некоторые отличия между `Stream` и коллекцией:

1. **Ленивая вычислительная модель:** Операции над `Stream` выполняются лениво, что означает, что они не будут выполняться до тех пор, пока не будет выполнена терминальная операция. Это позволяет оптимизировать использование ресурсов.

2. **Неизменяемость:** `Stream` не хранит данные, он выполняет операции над данными и создаёт новые потоки. Он не изменяет исходные данные.

3. **Функциональные операции:** Операции над `Stream` являются функциональными, такие как фильтрация, преобразование, сортировка и другие. Это способствует читаемости кода и упрощает обработку данных.

4. **Параллельная обработка:** `Stream` поддерживает параллельную обработку, что позволяет эффективно использовать многопоточность для ускорения выполнения операций.

5. **Функциональный стиль:** Работа с `Stream` подразумевает использование функционального стиля программирования, что может сделать код более компактным и выразительным.

В целом, `Stream` предоставляет мощный инструмент для обработки и агрегации данных, позволяя выполнять операции на более высоком уровне абстракции, чем прямая манипуляция коллекциями.

[к оглавлению](#коллекции-и-stream-api)

## Промежуточные и терминальные операции в stream.
В Java Stream API операции можно разделить на две основные категории: промежуточные и терминальные. Промежуточные операции применяются к потоку данных и создают новый поток данных с применением определенных операций, а терминальные операции выполняются в конце цепочки операций и завершают обработку потока данных. Давайте рассмотрим обе категории подробнее:

1. **Промежуточные операции (Intermediate Operations):**
   - `filter(Predicate)`: Отфильтровывает элементы потока в соответствии с заданным условием.
   - `map(Function)`: Преобразует каждый элемент потока с использованием заданной функции.
   - `flatMap(Function)`: Преобразует каждый элемент в поток и объединяет их в один поток.
   - `distinct()`: Удаляет дублирующиеся элементы из потока.
   - `sorted()`: Сортирует элементы потока.
   - `peek(Consumer)`: Выполняет заданное действие для каждого элемента потока без изменения потока.

2. **Терминальные операции (Terminal Operations):**
   - `forEach(Consumer)`: Выполняет заданное действие для каждого элемента потока.
   - `collect(Collector)`: Собирает элементы потока в коллекцию или другую структуру данных.
   - `reduce(BinaryOperator)`: Выполняет агрегацию элементов с использованием заданной функции.
   - `count()`: Возвращает количество элементов в потоке.
   - `min(Comparator)` / `max(Comparator)`: Возвращает минимальный или максимальный элемент потока.
   - `anyMatch(Predicate)` / `allMatch(Predicate)` / `noneMatch(Predicate)`: Проверяет соответствие элементов условию.
   - `findFirst()` / `findAny()`: Возвращает первый или любой элемент из потока.

Применение промежуточных операций создает цепочку операций, которая не будет выполнена, пока не будет вызвана терминальная операция. Терминальная операция вызывает фактическое выполнение операций и обработку данных в потоке.

[к оглавлению](#коллекции-и-stream-api)

## Методы: map() vs flatMap() в stream.
Методы `map()` и `flatMap()` в Java Stream API используются для преобразования элементов в потоке, но есть небольшая разница в том, как они это делают.

1. **Метод `map()`**:
   - Метод `map()` применяет заданную функцию к каждому элементу в потоке и возвращает новый поток, содержащий результаты преобразования.
   - Результаты преобразования остаются внутри отдельных элементов потока, так что после применения `map()` элементы остаются на том же уровне.

Пример использования `map()`:
```java
List<String> names = List.of("Alice", "Bob", "Charlie");
List<Integer> nameLengths = names.stream()
                                 .map(name -> name.length())
                                 .collect(Collectors.toList());
```

2. **Метод `flatMap()`**:
   - Метод `flatMap()` также применяет функцию к каждому элементу, но в отличие от `map()`, функция возвращает поток вместо отдельного значения.
   - Затем `flatMap()` объединяет все потоки, полученные из преобразования, в один поток.

Пример использования `flatMap()`:
```java
List<List<Integer>> numbers = List.of(
    List.of(1, 2, 3),
    List.of(4, 5, 6),
    List.of(7, 8, 9)
);
List<Integer> allNumbers = numbers.stream()
                                  .flatMap(List::stream)
                                  .collect(Collectors.toList());
```

В данном примере, без использования `flatMap()`, мы получили бы поток `Stream<List<Integer>>`, но с использованием `flatMap()` мы получили поток `Stream<Integer>`, в котором все числа объединены в один поток.

Когда использовать `map()` и `flatMap()` зависит от вашей задачи:
- Используйте `map()`, когда каждый элемент преобразуется в другой элемент на том же уровне.
- Используйте `flatMap()`, когда каждый элемент преобразуется в поток элементов, которые затем объединяются в один поток.
- 
[к оглавлению](#коллекции-и-stream-api)

## Что такое потоковая обработка данных?
Потоковая обработка данных (Stream Processing) - это подход к обработке и манипулированию последовательности элементов данных (например, коллекций, массивов, файлов) с использованием потоковых операций. Этот подход ориентирован на функциональное программирование и предоставляет более выразительные и удобные средства для работы с данными.

Основная идея потоковой обработки данных состоит в том, чтобы оперировать с данными как с последовательностью элементов, применяя к ним операции, которые могут быть объединены в цепочки, образуя цепочку операций (pipeline). Эти операции могут быть разделены на две категории: промежуточные и терминальные.

1. **Промежуточные операции**:
   - Это операции, которые принимают один поток данных и возвращают новый поток данных. Они обычно выполняют какие-то преобразования, фильтрации, сортировки и т.д. Эти операции могут быть объединены в цепочки.
   - Примеры: `filter()`, `map()`, `flatMap()`, `distinct()`, `sorted()` и др.

2. **Терминальные операции**:
   - Это операции, которые завершают цепочку операций и возвращают конечный результат. После выполнения терминальной операции нельзя продолжить операции над этим потоком данных.
   - Примеры: `collect()`, `forEach()`, `count()`, `min()`, `max()`, `reduce()` и др.

Преимущества потоковой обработки данных:
- **Удобство и читаемость кода**: Позволяет выразить операции над данными в виде последовательности методов, что делает код более читаемым и понятным.
- **Параллельная обработка**: Возможность автоматически распараллеливать операции, что увеличивает производительность на многоядерных процессорах.
- **Ленивость вычислений**: Потоковые операции выполняются только тогда, когда требуется получить результат (т.е. выполняются лениво).
- **Высокая абстракция**: Позволяет сосредоточиться на том, что делать с данными, а не на том, как это делать.

Java Stream API предоставляет мощные инструменты для потоковой обработки данных, позволяя более эффективно и читаемо работать с последовательностями элементов.

[к оглавлению](#коллекции-и-stream-api)
