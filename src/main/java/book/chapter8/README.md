# СТРОКИ
Вопросы:
- [1. Как создать объект класса String, какие существуют конструкторы класса String? Что такое строковый литерал? Что значит «упрощенное создание объекта String»?](#как-создать-объект-класса-string-какие-существуют-конструкторы-класса-string-что-такое-строковый-литерал-что-значит-упрощенное-создание-объекта-string)
- [2. Как реализован класс String, какие поля в нем объявлены?](#как-реализован-класс-string-какие-поля-в-нем-объявлены)
- [3. Как работает метод substring() класса String?](#как-работает-метод-substring-класса-string)
- [4. Можно ли изменить состояние объекта типа String? Что происходит при попытке изменения состояния объекта типа String? Можно ли наследоваться от класса String? Почему строковые объекты immutable?](#можно-ли-изменить-состояние-объекта-типа-string-что-происходит-при-попытке-изменения-состояния-объекта-типа-string-можно-ли-наследоваться-от-класса-string-почему-строковые-объекты-immutable)
- [5. Что такое пул литералов? Как строки заносятся в пул литералов? Как занести строку в пул литералов и как получить ссылку на строку, хранящуюся в пуле литералов? В каком отделе памяти хранится пул литералов в Java 1.6 и Java 1.7?](#что-такое-пул-литералов-как-строки-заносятся-в-пул-литералов-как-занести-строку-в-пул-литералов-и-как-получить-ссылку-на-строку-хранящуюся-в-пуле-литералов-в-каком-отделе-памяти-хранится-пул-литералов-в-java-16-и-java-17)
- [6. В чем отличие объектов классов StringBuilder и StringBuffer от объектов класса String? Какой из этих классов потокобезопасный?](#в-чем-отличие-объектов-классов-stringbuilder-и-stringbuffer-от-объектов-класса-string-какой-из-этих-классов-потокобезопасный)
- [7. Как необходимо сравнивать на равенство объекты классов StringBuilder и StringBuffer и почему?](#как-необходимо-сравнивать-на-равенство-объекты-классов-stringbuilder-и-stringbuffer-и-почему)
- [8. Что такое Unicode? Что такое code point? Отличия UTF-8 от UTF-16.](#что-такое-unicode-что-такое-code-point-отличия-utf-8-от-utf-16)
- [9. Как кодируется символ согласно кодировке UTF-8, UTF-16 и UTF-32?](#как-кодируется-символ-согласно-кодировке-utf-8-utf-16-и-utf-32)
- [10. Что такое кодировка? Какие кодировки вы знаете? Как создать строки в различной кодировке?](#что-такое-кодировка-какие-кодировки-вы-знаете-как-создать-строки-в-различной-кодировке)
- [11. Какие методы класса String используются для работы с кодовыми точками? Когда следует их использовать?](#какие-методы-класса-string-используются-для-работы-с-кодовыми-точками-когда-следует-их-использовать)
- [12. Что представляет собой регулярное выражение? Что такое метасимволы регулярного выражения? Какие существуют классы символов регулярных выражений? Что такое квантификаторы? Какие существуют логические операторы регулярных выражений?](#что-представляет-собой-регулярное-выражение-что-такое-метасимволы-регулярного-выражения-какие-существуют-классы-символов-регулярных-выражений-что-такое-квантификаторы-какие-существуют-логические-операторы-регулярных-выражений)
- [13. Какие классы Java работают с регулярными выражениями? В каком пакете они расположены?](#какие-классы-java-работают-с-регулярными-выражениями-в-каком-пакете-они-расположены)
- [14. Что такое группы в регулярных выражениях? Как нумеруются группы? Что представляет собой группа номер «0»?](#что-такое-группы-в-регулярных-выражениях-как-нумеруются-группы-что-представляет-собой-группа-номер-0)
- [15. Что такое интернационализация и локализация?](#что-такое-интернационализация-и-локализация)
- [16. Что представляет собой локаль в программе? Назначение объектов класса Locale? Как получить локаль? Как узнать, какие локали доступны?](#что-представляет-собой-локаль-в-программе-назначение-объектов-класса-locale-как-получить-локаль-как-узнать-какие-локали-доступны)
- [17. Какую информацию можно локализовать автоматически, применяя объект класса Locale? Как работают классы NumberFormat и DateFormat?](#какую-информацию-можно-локализовать-автоматически-применяя-объект-класса-locale-как-работают-классы-numberformat-и-dateformat)
- [18. Как можно локализовать приложение, используя класс ResourceBundle? Для каких еще целей, кроме локализации, можно применять объекты этого класса?](#как-можно-локализовать-приложение-используя-класс-resourcebundle-для-каких-еще-целей-кроме-локализации-можно-применять-объекты-этого-класса)

## Как создать объект класса String, какие существуют конструкторы класса String? Что такое строковый литерал? Что значит «упрощенное создание объекта String»?
Для создания объекта класса String в Java существует несколько способов:

1. С помощью строкового литерала (простое создание объекта String):
```java
String str1 = "Hello, World!";
```

2. С помощью конструктора без аргументов (создание пустой строки):
```java
String str2 = new String();
```

3. С помощью конструктора с передачей массива символов (char[]):
```java
char[] charArray = {'H', 'e', 'l', 'l', 'o'};
String str3 = new String(charArray);
```

4. С помощью конструктора с передачей массива символов и указанием начального и конечного индексов (создание строки из части массива символов):
```java
char[] charArray = {'H', 'e', 'l', 'l', 'o'};
String str4 = new String(charArray, 0, 2); // Создаст строку "He"
```

5. С помощью конструктора с передачей объекта класса StringBuilder или StringBuffer:
```java
StringBuilder stringBuilder = new StringBuilder("Hello");
String str5 = new String(stringBuilder);
```

Строковый литерал - это последовательность символов, заключенная в двойные кавычки. В Java строки, созданные с использованием строковых литералов, являются объектами класса String. Например, в строке `"Hello, World!"` `"Hello, World!"` - это строковый литерал, и он автоматически преобразуется в объект класса String.

Упрощенное создание объекта String означает использование строковых литералов для создания строк. Java автоматически создает объекты String для строковых литералов во время выполнения программы. Например, когда мы объявляем `String str = "Hello";`, Java создаст объект класса String, представляющий строку "Hello", и присвоит его переменной `str`. Это происходит автоматически без явного вызова конструктора.

[к оглавлению](#строки)

## Как реализован класс String, какие поля в нем объявлены?
Класс `String` в Java реализован как иммутабельный (неизменяемый) объект, что означает, что после создания объекта значения его полей не могут быть изменены. В классе `String` объявлено несколько полей:

1. `private final char[] value`: Это массив символов, который содержит фактические символы строки. Поскольку массив объявлен с модификатором `final`, его содержимое не может быть изменено после создания объекта, что делает строку неизменяемой.

2. `private final int hash`: Это поле содержит кэшированное значение хэш-кода строки. Хэш-код вычисляется один раз при создании объекта и сохраняется в этом поле, чтобы избежать повторных вычислений при повторных вызовах метода `hashCode()`.

3. `private static final long serialVersionUID`: Это поле используется для версионирования класса, когда сериализуемые объекты сохраняются или восстанавливаются.

Кроме того, класс `String` содержит различные методы для работы со строками, такие как `charAt()`, `length()`, `substring()`, `concat()`, `equals()`, `hashCode()`, и многие другие.

[к оглавлению](#строки)

## Как работает метод substring() класса String?
Метод `substring()` класса `String` возвращает новую подстроку из исходной строки. Он может быть вызван с одним или двумя аргументами:

1. `substring(int beginIndex)`: В этом случае метод возвращает подстроку, начиная с индекса `beginIndex` (включительно) и до конца исходной строки.

2. `substring(int beginIndex, int endIndex)`: В этом случае метод возвращает подстроку, начиная с индекса `beginIndex` (включительно) и до индекса `endIndex` (исключая `endIndex`). Таким образом, возвращаемая подстрока будет содержать символы от `beginIndex` до `endIndex-1`.

Оба аргумента метода `substring()` должны быть в пределах длины исходной строки, и `beginIndex` должен быть меньше или равен `endIndex`. В противном случае, метод вызовет исключение `IndexOutOfBoundsException`.

Пример использования `substring()`:

```java
String originalString = "Hello, World!";
String substring1 = originalString.substring(7); // результат: "World!"
String substring2 = originalString.substring(0, 5); // результат: "Hello"
```

Обратите внимание, что метод `substring()` не изменяет исходную строку, а создает новый объект `String`, содержащий нужную подстроку. Поскольку строки в Java являются неизменяемыми, создание новой подстроки приводит к созданию нового объекта `String`, который содержит соответствующую часть исходной строки.

[к оглавлению](#строки)

## Можно ли изменить состояние объекта типа String? Что происходит при попытке изменения состояния объекта типа String? Можно ли наследоваться от класса String? Почему строковые объекты immutable?
Объекты типа `String` в Java являются неизменяемыми (immutable). Это означает, что после создания строки инициализированной значением, она не может быть изменена. Если попытаться изменить состояние объекта типа `String`, то фактически будет создан новый объект `String`, содержащий измененное значение, а исходный объект останется неизменным.

Пример:

```java
String str = "Hello";
str = str + " World"; // создается новый объект String с содержимым "Hello World", а исходный объект "Hello" остается неизменным
```

Так как строки неизменяемы, они обладают рядом преимуществ, таких как:

1. Потокобезопасность: Из-за неизменяемости строки безопасно использовать их в многопоточных средах без синхронизации.

2. Кэширование хэш-кодов: Так как хэш-код строки не изменится после создания, его можно закэшировать и повторно использовать, что улучшает производительность.

3. Повторное использование объектов: При конкатенации или создании подстроки из существующей строки, Java может повторно использовать уже существующие объекты, если значения не изменились.

Что касается наследования от класса `String`, то он является `final` классом, что означает, что нельзя наследоваться от него. Это сделано для обеспечения неизменяемости строк. Если бы класс `String` не был `final`, то наследующий класс мог бы изменить его поведение и нарушить неизменяемость.

Из-за неизменяемости строк, класс `String` позволяет безопасно использовать его в многопоточных средах и обеспечивает надежность и предсказуемость поведения строковых операций.

[к оглавлению](#строки)

## Что такое пул литералов? Как строки заносятся в пул литералов? Как занести строку в пул литералов и как получить ссылку на строку, хранящуюся в пуле литералов? В каком отделе памяти хранится пул литералов в Java 1.6 и Java 1.7?
Пул литералов (string pool) - это механизм, используемый в Java для повторного использования строковых литералов, чтобы уменьшить накладные расходы на память и улучшить производительность. Когда строковый литерал создается в программе, он сначала ищется в пуле литералов. Если такая строка уже существует в пуле, то на нее возвращается ссылка, вместо создания нового объекта.

Строки в пуле литералов можно занести двумя способами:

1. С помощью строковых литералов в коде:

```java
String str1 = "Hello"; // этот литерал добавляется в пул литералов
```

2. С помощью метода `intern()`:

```java
String str2 = new String("Hello").intern(); // добавляет строку "Hello" в пул литералов
```

Чтобы получить ссылку на строку, хранящуюся в пуле литералов, можно вызвать метод `intern()` на уже существующей строке:

```java
String str3 = "Hello";
String str4 = str3.intern(); // str4 будет ссылаться на строку из пула литералов
```

Пул литералов в Java 1.6 и Java 1.7 находится в области памяти PermGen (Permanent Generation). Однако, начиная с Java 1.8, PermGen была заменена на область памяти Metaspace, и пул литералов теперь также находится в Metaspace. Metaspace является частью памяти, выделенной для хранения метаданных классов и строк, и он располагается в куче (heap).

[к оглавлению](#строки)

## В чем отличие объектов классов StringBuilder и StringBuffer от объектов класса String? Какой из этих классов потокобезопасный?
Основное отличие между классами `StringBuilder` и `StringBuffer` от класса `String` заключается в их изменяемости:

1. `String`: Класс `String` является неизменяемым (immutable). Это означает, что после создания объекта класса `String`, его значение не может быть изменено. Если нужно изменить строку, создается новый объект `String`.

```java
String str = "Hello";
str = str + " World"; // Создается новый объект String, содержащий "Hello World"
```

2. `StringBuilder` и `StringBuffer`: Классы `StringBuilder` и `StringBuffer` представляют изменяемые строки. Вы можете изменять содержимое объекта этих классов, добавлять символы, удалять символы и т.д. Они более эффективны при частых изменениях строк, так как не требуют создания новых объектов для каждой операции.

Отличие между `StringBuilder` и `StringBuffer` заключается в потокобезопасности:

- `StringBuilder`: Не является потокобезопасным. Это значит, что при использовании `StringBuilder` в многопоточной среде без синхронизации, могут возникать проблемы согласованности данных.

- `StringBuffer`: Является потокобезопасным. Все его методы синхронизированы, что позволяет безопасно использовать `StringBuffer` в многопоточной среде. Однако из-за этого он может работать немного медленнее, чем `StringBuilder` в однопоточной среде.

Выбор между `StringBuilder` и `StringBuffer` зависит от контекста использования. Если вы работаете в многопоточной среде и требуется потокобезопасность, используйте `StringBuffer`. В противном случае, в большинстве случаев `StringBuilder` будет предпочтительнее, так как он обычно работает быстрее.

[к оглавлению](#строки)

## Как необходимо сравнивать на равенство объекты классов StringBuilder и StringBuffer и почему?
Для сравнения объектов классов `StringBuilder` и `StringBuffer` на равенство, следует использовать метод `equals()`, который переопределен в классе `Object` и предоставляет сравнение по содержимому (содержанию) объектов.

```java
StringBuilder sb1 = new StringBuilder("Hello");
StringBuilder sb2 = new StringBuilder("Hello");

boolean areEqual = sb1.equals(sb2); // areEqual будет равно false

StringBuffer sf1 = new StringBuffer("Hello");
StringBuffer sf2 = new StringBuffer("Hello");

boolean areEqual2 = sf1.equals(sf2); // areEqual2 будет равно false
```

Однако следует быть осторожным при сравнении объектов классов `StringBuilder` и `StringBuffer`, так как эти классы не переопределяют метод `equals()` для сравнения по содержимому. В приведенном примере, хотя содержимое строк одинаково, объекты не будут считаться равными, так как метод `equals()` в классах `StringBuilder` и `StringBuffer` выполняет простое сравнение ссылок на объекты, а не их содержимого.

Для корректного сравнения содержимого строк, вам следует преобразовать объекты `StringBuilder` и `StringBuffer` в `String` и затем сравнивать строки:

```java
StringBuilder sb1 = new StringBuilder("Hello");
StringBuilder sb2 = new StringBuilder("Hello");

boolean areEqual = sb1.toString().equals(sb2.toString()); // areEqual будет равно true

StringBuffer sf1 = new StringBuffer("Hello");
StringBuffer sf2 = new StringBuffer("Hello");

boolean areEqual2 = sf1.toString().equals(sf2.toString()); // areEqual2 будет равно true
```

Теперь сравнение происходит по содержимому, а не по ссылкам на объекты.
[к оглавлению](#строки)

## Что такое Unicode? Что такое code point? Отличия UTF-8 от UTF-16.
Unicode - это стандарт для представления и обработки текста всех письменных систем мира, включая буквы, цифры, символы пунктуации и другие специальные символы. Каждому символу в стандарте Unicode присваивается уникальный числовой код, называемый code point.

Code point - это числовое значение, которое соответствует определенному символу в стандарте Unicode. Каждый символ в Unicode представлен одним или несколькими code point'ами.

UTF-8 и UTF-16 - это различные кодировки, которые используются для представления символов Unicode в виде последовательности байтов.

Отличия между UTF-8 и UTF-16:

1. Формат хранения:
    - UTF-8 представляет символы Unicode в виде последовательности байтов переменной длины. Для символов из базовой множественности (code point с номерами от 0 до 127) используется один байт, для остальных символов используются два, три или четыре байта.
    - UTF-16 представляет символы Unicode в виде последовательности 16-битных кодовых единиц (code units). Один code unit используется для представления символов из базовой множественности, а для остальных символов используются две code units.

2. Занимаемое место:
    - UTF-8 обычно занимает меньше места, чем UTF-16, для текста, состоящего в основном из символов из базовой множественности.
    - UTF-16 может занимать меньше места, чем UTF-8, для текста, содержащего много символов из небазовой множественности (например, символы других языков, эмодзи и т. д.).

3. Поддержка символов:
    - UTF-8 более широко используется в сетевых протоколах и форматах данных, так как обеспечивает совместимость с ASCII и обеспечивает компактное представление для текстов, состоящих в основном из символов из базовой множественности.
    - UTF-16 часто используется во внутреннем представлении строк в некоторых программных платформах, таких как Java и .NET, где каждый 16-битный code unit соответствует 16-битному символьному типу данных.

Важно выбирать подходящую кодировку в зависимости от конкретного контекста и требований вашего приложения или системы.

[к оглавлению](#строки)

## Как кодируется символ согласно кодировке UTF-8, UTF-16 и UTF-32?
Кодирование символа согласно кодировкам UTF-8, UTF-16 и UTF-32 происходит следующим образом:

1. UTF-8:
    - Символы из базовой множественности (code point с номерами от 0 до 127) кодируются одним байтом, представляющим символ в ASCII-кодировке.
    - Для символов из небазовой множественности используются многобайтовые последовательности. Количество байтов зависит от значения code point'а:
        - Символы с номерами от 128 до 2047 кодируются двумя байтами.
        - Символы с номерами от 2048 до 65535 кодируются тремя байтами.
        - Символы с номерами от 65536 до 1114111 кодируются четырьмя байтами.

2. UTF-16:
    - Все символы кодируются 16-битными code units. Символы из базовой множественности кодируются одним 16-битным code unit.
    - Символы из небазовой множественности кодируются двумя 16-битными code units. Этот процесс называется "суррогатное кодирование".

3. UTF-32:
    - Каждый символ кодируется одним 32-битным code unit, независимо от его значения.

Примеры:
1. Символ "A" (code point U+0041) в UTF-8 кодируется одним байтом: 01000001.
2. Символ "€" (code point U+20AC) в UTF-8 кодируется тремя байтами: 11100010 10000010 10101100.
3. Символ "🙂" (code point U+1F642) в UTF-16 кодируется двумя 16-битными code units: 110110 000011110010. (суррогатное кодирование)
4. Символ "🙂" (code point U+1F642) в UTF-32 кодируется одним 32-битным code unit: 0000000000000000000000011110010.

Эти кодировки обеспечивают представление символов различных языков и символов специального назначения в стандарте Unicode. Каждый символ всегда кодируется в определенный формат, что обеспечивает универсальность и совместимость при обработке текстов данных на разных платформах и в различных средах.

[к оглавлению](#строки)

## Что такое кодировка? Какие кодировки вы знаете? Как создать строки в различной кодировке?
Кодировка - это способ представления символов и текста с помощью числовых значений (code points) и их соответствующих двоичных представлений (code units) в памяти компьютера или на диске. Кодировки позволяют преобразовать символы в бинарные данные, которые могут быть переданы, хранены или обработаны компьютером.

Некоторые из наиболее известных кодировок включают:

1. ASCII (American Standard Code for Information Interchange) - одна из первых и наиболее распространенных кодировок, которая представляет символы латинского алфавита, цифры и некоторые специальные символы с помощью 7-битных двоичных значений.

2. UTF-8 (Unicode Transformation Format, 8-bit) - кодировка Unicode, которая использует переменное количество байтов для представления символов. Она обеспечивает совместимость с ASCII и поддерживает представление всех символов Unicode.

3. UTF-16 (Unicode Transformation Format, 16-bit) - еще одна кодировка Unicode, которая использует 16-битные кодовые единицы (code units) для представления символов. Она поддерживает все символы Unicode, включая символы из базовой и небазовой множественности.

4. UTF-32 (Unicode Transformation Format, 32-bit) - кодировка, которая использует 32-битные кодовые единицы для представления всех символов Unicode. UTF-32 гарантирует, что каждый символ будет занимать ровно 4 байта.

Для создания строк в различных кодировках в Java можно использовать классы `String` и `Charset`.

Пример создания строки в UTF-8 кодировке:

```java
String utf8String = "Привет, мир!";
byte[] utf8Bytes = utf8String.getBytes(StandardCharsets.UTF_8);
```

Пример создания строки в UTF-16 кодировке:

```java
String utf16String = "Привет, мир!";
byte[] utf16Bytes = utf16String.getBytes(StandardCharsets.UTF_16);
```

Пример создания строки в ASCII кодировке:

```java
String asciiString = "Hello, world!";
byte[] asciiBytes = asciiString.getBytes(StandardCharsets.US_ASCII);
```

Обратите внимание, что кодировка должна быть выбрана с учетом потребностей вашего приложения и особенностей используемых символов. UTF-8 является наиболее распространенной и рекомендуемой кодировкой для работы с символами всех языков и символов специального назначения.

[к оглавлению](#строки)

## Какие методы класса String используются для работы с кодовыми точками? Когда следует их использовать?
Для работы с кодовыми точками (code points) в классе `String` в Java можно использовать следующие методы:

1. `codePointAt(int index)`: Возвращает значение кодовой точки, находящейся в указанной позиции `index` строки. Этот метод может использоваться, когда необходимо получить значение кодовой точки для конкретной позиции в строке.

2. `codePointBefore(int index)`: Возвращает значение кодовой точки, находящейся перед указанной позицией `index` строки. Этот метод также может использоваться для получения значения кодовой точки перед указанной позицией.

3. `codePointCount(int beginIndex, int endIndex)`: Возвращает количество кодовых точек между позициями `beginIndex` и `endIndex` (не включая позицию `endIndex`). Этот метод полезен, когда нужно определить количество кодовых точек в определенном диапазоне строки.

4. `offsetByCodePoints(int index, int codePointOffset)`: Возвращает индекс (позицию) в строке, смещенный на значение `codePointOffset` относительно индекса `index`. Этот метод может использоваться для навигации по кодовым точкам в строке.

Методы для работы с кодовыми точками полезны, когда имеется необходимость обработки символов, кодовых точек и символьных кластеров, особенно в многоязычных и многобайтовых строках. Если вам требуется работать с символами на уровне кодовых точек, эти методы могут быть полезными для выполнения таких операций, как извлечение или обработка символов, вычисление длины строки в кодовых точках, и т. д.

[к оглавлению](#строки)

## Что представляет собой регулярное выражение? Что такое метасимволы регулярного выражения? Какие существуют классы символов регулярных выражений? Что такое квантификаторы? Какие существуют логические операторы регулярных выражений?
Регулярное выражение (regular expression или regex) - это строка, которая представляет собой шаблон поиска или сопоставления текста. Оно используется для поиска определенных паттернов в строках или текстах. Регулярные выражения обеспечивают мощные инструменты для работы с текстовыми данными, такие как поиск, замена, проверка на соответствие и т. д.

Метасимволы регулярного выражения - это специальные символы, которые представляют классы символов или квантификаторы и имеют специальное значение в регулярных выражениях. Некоторые распространенные метасимволы включают:

1. `.` (точка): Представляет любой символ, кроме символа новой строки.
2. `*`: Представляет 0 или более повторений предыдущего символа или группы.
3. `+`: Представляет 1 или более повторений предыдущего символа или группы.
4. `?`: Представляет 0 или 1 повторение предыдущего символа или группы.
5. `\`: Используется для экранирования метасимволов, чтобы они интерпретировались как обычные символы.
6. `[]`: Определяет класс символов, соответствующих одному из символов внутри скобок.
7. `|`: Используется для указания альтернативы между двумя выражениями.

Существует множество классов символов, которые позволяют определить группы символов для сопоставления. Некоторые из них:

1. `[a-z]`: Определяет класс символов от "a" до "z".
2. `[A-Z]`: Определяет класс символов от "A" до "Z".
3. `[0-9]`: Определяет класс символов от "0" до "9".
4. `\d`: Определяет любую цифру (эквивалентно `[0-9]`).
5. `\w`: Определяет любую букву или цифру или символ подчеркивания (эквивалентно `[a-zA-Z0-9_]`).
6. `\s`: Определяет любой символ пробела (пробел, табуляция, новая строка и т. д.).

Квантификаторы позволяют указывать количество повторений символов или групп. Некоторые из них:

1. `*`: Ноль или более повторений.
2. `+`: Один или более повторений.
3. `?`: Ноль или одно повторение.
4. `{n}`: Ровно n повторений.
5. `{n,}`: n или более повторений.
6. `{n,m}`: От n до m повторений.

Логические операторы в регулярных выражениях позволяют соединять несколько выражений в одно. Одним из таких операторов является вертикальная черта `|`, которая позволяет указать альтернативу между двумя выражениями. Например, `a|b` будет соответствовать либо "a", либо "b".

Примечание: Для использования регулярных выражений в Java, вы можете использовать классы `Pattern` и `Matcher` из пакета `java.util.regex`.

[к оглавлению](#строки)

## Какие классы Java работают с регулярными выражениями? В каком пакете они расположены?
В Java для работы с регулярными выражениями используются следующие классы:

1. `java.util.regex.Pattern`: Этот класс представляет регулярное выражение и позволяет компилировать его в объект `Pattern`, который может быть использован для сопоставления с текстом.

2. `java.util.regex.Matcher`: Этот класс используется для сопоставления регулярного выражения с текстом. Он получает `Pattern` в качестве входного параметра и выполняет сопоставление с текстом, а также предоставляет информацию о совпадениях и группах.

Эти классы находятся в пакете `java.util.regex`, который предоставляет функциональность для работы с регулярными выражениями в Java.

[к оглавлению](#строки)

## Что такое группы в регулярных выражениях? Как нумеруются группы? Что представляет собой группа номер «0»?
В регулярных выражениях группы используются для выделения подстрок, которые соответствуют определенным частям регулярного выражения. Каждая группа заключается в круглые скобки `()`.

Группы нумеруются начиная с 1. Первая открывающая скобка соответствует группе 1, вторая - группе 2, и так далее.

Группа с номером 0 обозначает всю подстроку, соответствующую всему регулярному выражению. Таким образом, если вы используете группы в регулярном выражении, то группа с номером 0 будет содержать всю найденную подстроку, а группы с номерами 1, 2, 3 и т.д. будут содержать подстроки, соответствующие выделенным группам в регулярном выражении.

[к оглавлению](#строки)

## Что такое интернационализация и локализация?
Интернационализация (Internationalization) и локализация (Localization) - это процессы, связанные с адаптацией программного обеспечения и веб-сайтов под различные языки и культуры, чтобы они были доступны и понятны для пользователей из разных стран и регионов.

Интернационализация (I18N) - это процесс разработки программного обеспечения или веб-сайтов таким образом, чтобы они были готовы к легкому адаптированию под различные языки и региональные особенности. Он включает в себя использование международных стандартов для хранения текста и данных, избегание хардкодинга строк, использование кодировок Unicode, правильное форматирование дат, времени, чисел и валют, а также другие подходы, которые делают программное обеспечение гибким и готовым к локализации.

Локализация (L10N) - это процесс адаптации интернационализированного программного обеспечения или веб-сайта под конкретный язык и культуру. В ходе локализации происходит перевод текстов на нужный язык, а также настройка форматирования дат, времени и чисел в соответствии с правилами конкретной локали. Целью локализации является предоставление пользователю нативного опыта использования программного обеспечения или веб-сайта, что делает его более доступным и удобным для пользователя из определенного региона.

Общими инструментами для интернационализации и локализации являются использование ресурсных файлов с переводами, использование API и библиотек, поддерживающих локализацию, и тестирование на различных языках и региональных настройках.

[к оглавлению](#строки)

## Что представляет собой локаль в программе? Назначение объектов класса Locale? Как получить локаль? Как узнать, какие локали доступны?
В программировании локаль (Locale) представляет собой среду, в которой выполняется программное обеспечение или приложение. Локаль определяет различные параметры для форматирования текста, времени, даты, чисел и валюты в соответствии с языком, страной и региональными настройками пользователя.

Объекты класса `Locale` в Java представляют информацию о конкретной локали. Они содержат информацию о языке, стране и варианте локали. Класс `Locale` предоставляет несколько конструкторов и статических методов для создания объектов `Locale` на основе заданных параметров.

Пример создания объекта `Locale` для английской локали США:

```java
Locale locale = new Locale("en", "US");
```

Пример получения локали по умолчанию:

```java
Locale defaultLocale = Locale.getDefault();
```

Для получения списка доступных локалей в Java, можно использовать статический метод `getAvailableLocales()` из класса `Locale`. Этот метод возвращает массив объектов `Locale`, которые представляют поддерживаемые в системе локали.

Пример получения списка доступных локалей:

```java
Locale[] availableLocales = Locale.getAvailableLocales();
for (Locale locale : availableLocales) {
    System.out.println(locale);
}
```

Когда программа должна предоставить локализованный опыт пользователю, объекты `Locale` используются вместе с другими классами, такими как `DateFormat`, `NumberFormat`, `Currency`, `ResourceBundle` и другими, чтобы форматировать и представлять данные в соответствии с выбранной локалью. Это позволяет программам поддерживать различные языки и региональные настройки без необходимости изменения самого кода.

[к оглавлению](#строки)

## Какую информацию можно локализовать автоматически, применяя объект класса Locale? Как работают классы NumberFormat и DateFormat?
Объекты класса `Locale` позволяют локализовать автоматически различные аспекты программы, такие как форматирование чисел, дат, времени, валюты и текстовых сообщений. Путем использования объектов `Locale`, можно адаптировать вывод программы к языку и предпочтениям пользователя, что обеспечивает более удобный опыт использования для пользователей разных стран и регионов.

Классы `NumberFormat` и `DateFormat` позволяют форматировать числа и даты соответственно, применяя заданную локаль. При форматировании чисел и дат, классы используют информацию из объекта `Locale` для определения правил форматирования, таких как разделитель тысяч, десятичный разделитель, символы даты и времени и т.д., соответствующие выбранной локали.

Пример использования `NumberFormat` для форматирования чисел с учетом локали:

```java
Locale locale = new Locale("en", "US");
NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);

double number = 12345.6789;
String formattedNumber = numberFormat.format(number);

System.out.println(formattedNumber); // Output: 12,345.679
```

Пример использования `DateFormat` для форматирования даты и времени с учетом локали:

```java
Locale locale = new Locale("fr", "FR");
DateFormat dateFormat = DateFormat.getDateInstance(DateFormat.LONG, locale);

Date currentDate = new Date();
String formattedDate = dateFormat.format(currentDate);

System.out.println(formattedDate); // Output: 26 juillet 2023
```

Когда классы `NumberFormat` и `DateFormat` форматируют числа и даты, они автоматически используют информацию из объекта `Locale`, чтобы определить соответствующие форматы и правила для текущей локали. Это позволяет приложению быть легко локализуемым и адаптироваться к разным регионам и языкам без изменения самого кода.

[к оглавлению](#строки)

## Как можно локализовать приложение, используя класс ResourceBundle? Для каких еще целей, кроме локализации, можно применять объекты этого класса?
Класс `ResourceBundle` в Java предоставляет механизм для локализации приложения путем предоставления различных ресурсных файлов для разных локалей. Ресурсные файлы содержат переводы текстовых сообщений, меток, ошибок и других строковых значений, которые могут быть отображены в зависимости от выбранной локали.

Для локализации приложения с помощью класса `ResourceBundle`, следует выполнить следующие шаги:

1. Создать ресурсные файлы для каждой локали, которую необходимо поддерживать. Например, для английского языка, файл может называться `messages_en.properties`, а для французского языка - `messages_fr.properties`. В этих файлах следует указать ключи и соответствующие переводы текстовых сообщений.

2. Загрузить ресурсные файлы в приложение с помощью класса `ResourceBundle`. Например:

```java
Locale locale = new Locale("fr", "FR");
ResourceBundle bundle = ResourceBundle.getBundle("messages", locale);
```

3. Получить переводы текстовых сообщений из ресурсного файла с помощью метода `getString()`:

```java
String welcomeMessage = bundle.getString("welcome.message");
System.out.println(welcomeMessage);
```

Теперь, при запуске приложения с локалью "fr_FR", будет выведено сообщение на французском языке.

Кроме локализации, объекты `ResourceBundle` можно использовать для других целей, таких как управление конфигурационными параметрами, хранение текстовых ресурсов для различных версий приложения (например, для разных платформ или устройств), а также для разделения текстовых сообщений от кода приложения, что делает его более читаемым и поддерживаемым.

[к оглавлению](#строки)