# ФУНКЦИОНАЛЬНЫЕ ИНТЕРФЕЙСЫ
Вопросы:
- [1. Дать определение функционального интерфейса. default & static методы. Область применения. Каким образом вызываются?](#дать-определение-функционального-интерфейса-default--static-методы-область-применения-каким-образом-вызываются)
- [2. Что такое лямбда-выражение? Его структура.](#что-такое-лямбда-выражение-его-структура)
- [3. Замыкание. К каким переменным есть доступ у лямбда-выражения?](#замыкание-к-каким-переменным-есть-доступ-у-лямбда-выражения)
- [4. Ссылка на метод. Какие существуют ссылки на методы?](#ссылка-на-метод-какие-существуют-ссылки-на-методы)
- [5. Ссылка на конструктор. Как применяется?](#ссылка-на-конструктор-как-применяется)
- [6. Интерфейс Function. Его назначение. Какие существуют близкие по смыслу интерфейсы и почему можно сделать такой вывод?](#интерфейс-function-его-назначение-какие-существуют-близкие-по-смыслу-интерфейсы-и-почему-можно-сделать-такой-вывод)
- [7. Интерфейс UnaryOperator. Его назначение. Сравнить с интерфейсом Function.](#интерфейс-unaryoperator-его-назначение-сравнить-с-интерфейсом-function)
- [8. Интерфейс Supplier. Его назначение. Какие существуют близкие по смыслу интерфейсы и почему можно сделать такой вывод?](#интерфейс-supplier-его-назначение-какие-существуют-близкие-по-смыслу-интерфейсы-и-почему-можно-сделать-такой-вывод)
- [9. Интерфейс Predicate. Его назначение. Какие существуют близкие по смыслу интерфейсы и почему можно сделать такой вывод?](#интерфейс-predicate-его-назначение-какие-существуют-близкие-по-смыслу-интерфейсы-и-почему-можно-сделать-такой-вывод)
- [10. Интерфейс Consumer. Его назначение. Какие существуют близкие по смыслу интерфейсы и почему можно сделать такой вывод?](#интерфейс-consumer-его-назначение-какие-существуют-близкие-по-смыслу-интерфейсы-и-почему-можно-сделать-такой-вывод)
- [11. Интерфейс Comparator. Его назначение.](#интерфейс-comparator-его-назначение)
- [12. Как создать собственный функциональный интерфейс?](#как-создать-собственный-функциональный-интерфейс)
- [13. Как сортировать список с применением лямбда-выражений?](#как-сортировать-список-с-применением-лямбда-выражений)
- [14. Можно ли называть интерфейс функциональным, если при его объявлении не была применена аннотация @FunctionalInterface?](#можно-ли-называть-интерфейс-функциональным-если-при-его-объявлении-не-была-применена-аннотация-functionalinterface)

## Дать определение функционального интерфейса. default & static методы. Область применения. Каким образом вызываются?
Функциональный интерфейс (Functional Interface) - это интерфейс, который содержит только один абстрактный метод. Такой интерфейс предназначен для использования в лямбда-выражениях или ссылках на методы и является основой для функционального программирования в Java.

Основные свойства функционального интерфейса:
1. Содержит только один абстрактный метод.
2. Может содержать несколько default или static методов, но только один абстрактный метод.
3. Аннотация `@FunctionalInterface` может быть применена к таким интерфейсам, чтобы явно указать, что данный интерфейс предназначен для использования как функциональный.

Default методы (методы по умолчанию) - это методы, которые имеют реализацию в интерфейсе и предоставляют дефолтную функциональность. Если класс реализует интерфейс, но не предоставляет свою реализацию для default метода, то будет использована реализация из самого интерфейса.

Static методы (статические методы) в интерфейсах были добавлены в Java 8. Они имеют реализацию в интерфейсе и могут быть вызваны без создания объекта класса, реализующего интерфейс.

Область применения функциональных интерфейсов и default/static методов:
- Лямбда-выражения и ссылки на методы: Функциональные интерфейсы позволяют создавать лаконичные анонимные функции с помощью лямбда-выражений или ссылок на методы.
- Работа с потоками данных: Функциональные интерфейсы часто используются в API для работы с потоками данных (Stream API), таких как `map`, `filter`, `forEach` и т.д.
- Обработка событий: Использование функциональных интерфейсов позволяет обрабатывать события и действия с помощью лямбда-выражений.

Вызов default и static методов осуществляется через имя интерфейса, без создания объекта класса, реализующего интерфейс. Например:

```java
public interface MyInterface {
    default void defaultMethod() {
        System.out.println("This is a default method in MyInterface");
    }

    static void staticMethod() {
        System.out.println("This is a static method in MyInterface");
    }
}

public class MyClass implements MyInterface {
    public static void main(String[] args) {
        // Вызов default метода через объект класса
        MyClass myObject = new MyClass();
        myObject.defaultMethod();

        // Вызов default метода через имя интерфейса
        MyInterface.staticMethod();
    }
}
```

В этом примере `defaultMethod()` вызывается через объект класса, который реализует интерфейс, а `staticMethod()` вызывается через имя интерфейса без создания объекта класса.

[к оглавлению](#функциональные-интерфейсы)

## Что такое лямбда-выражение? Его структура.
Лямбда-выражение (Lambda Expression) - это компактный способ представления анонимных функций, которые могут быть использованы в Java. Лямбда-выражения добавлены в язык Java начиная с версии 8, и они позволяют передавать функции как аргументы в методы, сохранять их в переменных, возвращать из методов и использовать в функциональных интерфейсах.

Структура лямбда-выражения выглядит следующим образом:

```
(parameters) -> expression
```

где:
- `parameters`: список параметров, которые принимает лямбда-функция. Если функция не принимает параметров, список остается пустым. Если функция принимает один параметр, скобки вокруг параметра можно опустить. Если функция принимает несколько параметров, они разделяются запятыми.
- `->`: оператор лямбда, который разделяет параметры и тело функции.
- `expression`: тело лямбда-функции, содержащее выражение, которое нужно выполнить. Если тело функции состоит из нескольких выражений, оно заключается в фигурные скобки `{}` и завершается оператором `return`.

Примеры лямбда-выражений:

1. Лямбда-выражение без параметров:
```java
() -> System.out.println("Hello, World!");
```

2. Лямбда-выражение с одним параметром:
```java
(name) -> System.out.println("Hello, " + name);
```

3. Лямбда-выражение с несколькими параметрами:
```java
(x, y) -> x + y;
```

4. Лямбда-выражение с несколькими выражениями в теле:
```java
(x, y) -> {
    int sum = x + y;
    System.out.println("Sum: " + sum);
    return sum;
};
```

Лямбда-выражения часто используются вместе с функциональными интерфейсами для создания компактного и выразительного кода. В функциональных интерфейсах определен единственный абстрактный метод, который соответствует сигнатуре лямбда-выражения, и благодаря этому можно использовать лямбда-выражения для создания объектов функциональных интерфейсов. Например:

```java
@FunctionalInterface
interface MyFunction {
    void doSomething();
}

public class Main {
    public static void main(String[] args) {
        // Использование лямбда-выражения для создания объекта функционального интерфейса
        MyFunction func = () -> System.out.println("Doing something...");
        func.doSomething(); // Выводит "Doing something..."
    }
}
```

В этом примере мы определяем функциональный интерфейс `MyFunction` с методом `doSomething()`. Затем мы используем лямбда-выражение для создания объекта `MyFunction` и вызываем его метод `doSomething()`.

[к оглавлению](#функциональные-интерфейсы)

## Замыкание. К каким переменным есть доступ у лямбда-выражения?
Замыкание (Closure) - это функция, которая ссылается на свои свободные переменные (переменные, которые не являются параметрами функции и не определены внутри функции). Лямбда-выражения в Java являются замыканиями, что означает, что они могут иметь доступ к переменным, определенным вне их собственной области видимости.

Лямбда-выражения имеют доступ к следующим переменным:

1. Переменные экземпляра: Лямбда-выражения, определенные внутри нестатических методов, могут обращаться к переменным экземпляра, определенным в том же классе.

2. Статические переменные: Лямбда-выражения имеют доступ к статическим переменным, определенным в том же классе.

3. Локальные переменные: Лямбда-выражения могут обращаться к локальным переменным, определенным в теле метода, в котором лямбда-выражение определено. Однако есть одно важное правило - локальные переменные, к которым обращается лямбда-выражение, должны быть объявлены как `final` или эффективно неизменяемыми. Если такие переменные не объявлены как `final`, компилятор пытается сделать их `final` самостоятельно.

Пример использования замыкания:

```java
public class Main {
    private static int staticVar = 10;
    
    public static void main(String[] args) {
        int localVar = 5;
        
        // Лямбда-выражение имеет доступ к переменным staticVar и localVar
        MyFunction func = () -> {
            System.out.println("Accessing static variable: " + staticVar);
            System.out.println("Accessing local variable: " + localVar);
        };
        
        func.doSomething();
    }
}

@FunctionalInterface
interface MyFunction {
    void doSomething();
}
```

В этом примере лямбда-выражение `func` имеет доступ к статической переменной `staticVar` и локальной переменной `localVar`, определенным в методе `main()`.

[к оглавлению](#функциональные-интерфейсы)

## Ссылка на метод. Какие существуют ссылки на методы?
Ссылка на метод (Method Reference) - это сокращенная форма записи лямбда-выражений для вызова метода. Она позволяет передать метод как аргумент в другой метод или использовать его вместо лямбда-выражения там, где ожидается функциональный интерфейс. Ссылка на метод делает код более читаемым и компактным.

Существуют несколько видов ссылок на методы в Java:

1. Ссылка на статический метод: Ссылка на статический метод определенного класса. Синтаксис: `ClassName::staticMethodName`.

2. Ссылка на метод экземпляра объекта: Ссылка на нестатический метод конкретного объекта. Синтаксис: `objectReference::instanceMethodName`.

3. Ссылка на метод экземпляра класса: Ссылка на нестатический метод класса без создания объекта. Синтаксис: `ClassName::instanceMethodName`.

4. Ссылка на конструктор: Ссылка на конструктор класса. Синтаксис: `ClassName::new`.

Примеры использования ссылок на методы:

```java
import java.util.ArrayList;
import java.util.List;

public class Main {
    public static void main(String[] args) {
        // Пример ссылки на статический метод
        List<String> names = new ArrayList<>();
        names.add("Alice");
        names.add("Bob");
        names.add("Charlie");
        names.forEach(Main::printName);

        // Пример ссылки на метод экземпляра объекта
        MyPrinter myPrinter = new MyPrinter();
        names.forEach(myPrinter::print);

        // Пример ссылки на метод экземпляра класса
        names.forEach(String::toUpperCase);

        // Пример ссылки на конструктор
        MyFactory factory = MyObject::new;
        MyObject obj = factory.create();
    }

    public static void printName(String name) {
        System.out.println(name);
    }
}

class MyPrinter {
    public void print(String str) {
        System.out.println(str);
    }
}

class MyObject {
    public MyObject() {
        System.out.println("MyObject created!");
    }
}

@FunctionalInterface
interface MyFactory {
    MyObject create();
}
```

Здесь показаны примеры различных типов ссылок на методы, включая статический метод, метод экземпляра объекта, метод экземпляра класса и конструктор.

[к оглавлению](#функциональные-интерфейсы)

## Ссылка на конструктор. Как применяется?
Ссылка на конструктор используется для создания объекта с помощью ссылки на конструктор класса. Это позволяет создать объект без явного вызова конструктора, что делает код более читаемым и компактным.

Ссылка на конструктор имеет следующий синтаксис: `ClassName::new`.

Пример использования ссылки на конструктор:

```java
import java.util.function.Supplier;

public class Main {
    public static void main(String[] args) {
        // Пример ссылки на конструктор
        Supplier<MyObject> factory = MyObject::new;
        MyObject obj = factory.get();
    }
}

class MyObject {
    public MyObject() {
        System.out.println("MyObject created!");
    }
}
```

В данном примере, `Supplier<MyObject>` - это функциональный интерфейс, который предоставляет метод `get()`. Поскольку конструктор `MyObject()` не принимает аргументов, ссылка на конструктор может быть использована для создания объекта типа `MyObject` без явного вызова `new MyObject()`. Вызов `factory.get()` создаст объект `MyObject` и выведет "MyObject created!" на консоль.

[к оглавлению](#функциональные-интерфейсы)

## Интерфейс Function. Его назначение. Какие существуют близкие по смыслу интерфейсы и почему можно сделать такой вывод?
Интерфейс `Function` является частью пакета `java.util.function` в Java. Его назначение - предоставить функциональный интерфейс для представления функций, которые принимают один аргумент и возвращают результат.

Основное назначение интерфейса `Function` заключается в том, чтобы облегчить работу с функциями, которые принимают и возвращают значения. Он часто используется в лямбда-выражениях и ссылках на методы, а также в потоках данных (Stream API) для преобразования данных из одной формы в другую.

Вот его общий синтаксис:

```java
interface Function<T, R> {
    R apply(T t);
}
```

Где:
- `T` - тип аргумента функции.
- `R` - тип возвращаемого значения функции.

Другие близкие по смыслу интерфейсы в пакете `java.util.function` включают:

1. `Supplier<T>` - представляет функцию, которая не принимает аргументов, но возвращает значение типа `T`. (`T get()`).

2. `Consumer<T>` - представляет функцию, которая принимает аргумент типа `T`, но не возвращает результат. (`void accept(T t)`).

3. `Predicate<T>` - представляет функцию, которая принимает аргумент типа `T` и возвращает логическое значение `true` или `false`. (`boolean test(T t)`).

4. `UnaryOperator<T>` - представляет функцию, которая принимает аргумент типа `T` и возвращает значение того же типа `T`. (`T apply(T t)`).

Все эти интерфейсы предназначены для работы с разными типами функций, что делает код более гибким и позволяет использовать функциональное программирование в Java.

[к оглавлению](#функциональные-интерфейсы)

## Интерфейс UnaryOperator. Его назначение. Сравнить с интерфейсом Function.
Интерфейс `UnaryOperator<T>` также является частью пакета `java.util.function` в Java. Его назначение - представить функциональный интерфейс, который принимает один аргумент типа `T` и возвращает результат того же типа `T`.

Вот его общий синтаксис:

```java
interface UnaryOperator<T> extends Function<T, T> {
    // Нет необходимости определять новые методы, так как он наследует метод apply(T t) от Function.
}
```

Как видно из синтаксиса, `UnaryOperator<T>` расширяет интерфейс `Function<T, T>`, но не добавляет новых методов, потому что он работает точно так же, как и `Function<T, T>`. Разница между ними заключается только в именах и названиях интерфейсов.

Основное различие между `UnaryOperator<T>` и `Function<T, T>` заключается в удобстве использования и наглядности кода. Используя `UnaryOperator<T>`, можно сразу сказать, что функция принимает и возвращает значение одного и того же типа `T`, что делает код более ясным и легко читаемым.

Пример использования `UnaryOperator<T>` для удвоения числа:

```java
import java.util.function.UnaryOperator;

public class Main {
    public static void main(String[] args) {
        UnaryOperator<Integer> doubleNumber = n -> n * 2;
        int result = doubleNumber.apply(5);
        System.out.println(result); // Output: 10
    }
}
```

То же самое можно сделать с помощью `Function<T, T>`:

```java
import java.util.function.Function;

public class Main {
    public static void main(String[] args) {
        Function<Integer, Integer> doubleNumber = n -> n * 2;
        int result = doubleNumber.apply(5);
        System.out.println(result); // Output: 10
    }
}
```

Как видно из примеров, оба подхода дают один и тот же результат. Однако использование `UnaryOperator<T>` делает код более читаемым и понятным.

[к оглавлению](#функциональные-интерфейсы)

## Интерфейс Supplier. Его назначение. Какие существуют близкие по смыслу интерфейсы и почему можно сделать такой вывод?
Интерфейс `Supplier<T>` также является частью пакета `java.util.function` в Java. Его назначение - представить функциональный интерфейс, который не принимает аргументов, но возвращает значение типа `T`.

Вот его общий синтаксис:

```java
interface Supplier<T> {
    T get();
}
```

Метод `get()` не принимает аргументов, но возвращает значение типа `T`.

Интерфейс `Supplier<T>` часто используется в ситуациях, когда нужно получить значение или создать объект без каких-либо входных данных. Он удобен для ленивой инициализации, когда вы не хотите создавать объекты до тех пор, пока они не понадобятся.

Другие близкие по смыслу интерфейсы в пакете `java.util.function` включают:

1. `Callable<T>`: Этот интерфейс также представляет задачу, которая возвращает результат и может генерировать исключение. Он предоставляет метод `call()`, который возвращает значение типа `T` и может выбрасывать исключение. В отличие от `Supplier<T>`, `Callable<T>` может генерировать проверяемые исключения.

2. `Function<Void, T>`: Этот интерфейс является альтернативой `Supplier<T>` и предоставляет метод `apply(Void input)`, который принимает аргумент типа `Void` (то есть отсутствующий аргумент) и возвращает значение типа `T`. Он часто используется, когда необходимо обернуть логику, требующую отсутствия входных данных, в функциональный интерфейс.

3. `Runnable`: Этот интерфейс не возвращает никакого значения и не принимает аргументов. Он предоставляет метод `run()`, который используется для выполнения каких-либо действий или задач.

Все эти интерфейсы представляют собой способы получения значения или выполнения задачи без входных данных и часто используются в функциональном программировании или при работе с лямбда-выражениями и методами ссылок.

[к оглавлению](#функциональные-интерфейсы)

## Интерфейс Predicate. Его назначение. Какие существуют близкие по смыслу интерфейсы и почему можно сделать такой вывод?
Интерфейс `Predicate<T>` также является частью пакета `java.util.function` в Java. Его назначение - представить функциональный интерфейс, который принимает аргумент типа `T` и возвращает булево значение (`true` или `false`).

Вот его общий синтаксис:

```java
interface Predicate<T> {
    boolean test(T t);
}
```

Метод `test(T t)` принимает аргумент типа `T` и возвращает `true`, если условие выполняется для данного аргумента, и `false` в противном случае. Этот интерфейс позволяет выполнять различные проверки на предмет соответствия условию для разных типов данных.

Интерфейс `Predicate<T>` широко используется в функциональном программировании, а также в API Java, где требуется предикат для фильтрации или проверки элементов. Он позволяет создавать компактные и лаконичные проверки, которые могут быть переданы в методы для выполнения различных операций.

Некоторые другие близкие по смыслу интерфейсы в пакете `java.util.function` включают:

1. `Function<T, R>`: Этот интерфейс также принимает аргумент типа `T`, но возвращает результат типа `R`. В отличие от `Predicate<T>`, он предназначен для преобразования элемента из одного типа в другой, а не для возвращения булевого значения.

2. `Consumer<T>`: Этот интерфейс принимает аргумент типа `T`, но не возвращает никакого значения. Он используется для выполнения действий или операций над элементами, а не для проверки условий.

3. `Supplier<T>`: Этот интерфейс не принимает никаких аргументов и возвращает значение типа `T`. В отличие от `Predicate<T>`, он предназначен для создания или предоставления значений, а не для выполнения проверок.

Все эти интерфейсы предоставляют способы применения функционального программирования и работы с лямбда-выражениями для различных задач, что делает код более читаемым и легким в понимании. Они позволяют разделять логику и действия, а также упрощают работу с коллекциями и потоками данных в Java.

[к оглавлению](#функциональные-интерфейсы)

## Интерфейс Consumer. Его назначение. Какие существуют близкие по смыслу интерфейсы и почему можно сделать такой вывод?
Интерфейс `Consumer<T>` является частью пакета `java.util.function` в Java. Его назначение - представить функциональный интерфейс, который принимает аргумент типа `T`, но не возвращает никакого значения (т.е., производит какое-либо действие с переданным аргументом).

Вот его общий синтаксис:

```java
interface Consumer<T> {
    void accept(T t);
}
```

Метод `accept(T t)` принимает аргумент типа `T` и выполняет некоторое действие или операцию над этим аргументом. Например, он может выводить его на консоль, записывать в файл, добавлять в коллекцию или выполнять другие манипуляции с данными.

Интерфейс `Consumer<T>` широко используется в функциональном программировании, особенно в контексте работы с коллекциями и потоками данных. Он позволяет передавать функции-потребителя в различные методы, чтобы выполнить операции над элементами коллекции без явного использования циклов.

Некоторые другие близкие по смыслу интерфейсы в пакете `java.util.function` включают:

1. `Function<T, R>`: Этот интерфейс принимает аргумент типа `T` и возвращает результат типа `R`. В отличие от `Consumer<T>`, он предназначен для преобразования элемента из одного типа в другой, а не для выполнения действий.

2. `Predicate<T>`: Этот интерфейс также принимает аргумент типа `T`, но возвращает булево значение (`true` или `false`). В отличие от `Consumer<T>`, он предназначен для выполнения проверок или фильтрации элементов, а не для выполнения действий над ними.

3. `Supplier<T>`: Этот интерфейс не принимает никаких аргументов и возвращает значение типа `T`. В отличие от `Consumer<T>`, он предназначен для создания или предоставления значений, а не для их обработки.

Все эти интерфейсы предоставляют различные способы работы с функциональным программированием и лямбда-выражениями в Java. Они позволяют разделять логику и действия, а также упрощают работу с коллекциями и потоками данных. Использование различных интерфейсов из пакета `java.util.function` позволяет писать более читаемый, гибкий и модульный код.

[к оглавлению](#функциональные-интерфейсы)

## Интерфейс Comparator. Его назначение.
Интерфейс `Comparator<T>` в Java предназначен для сравнения объектов типа `T`. Он является частью пакета `java.util` и используется для определения пользовательской логики сравнения объектов, которая может отличаться от стандартного метода сравнения (`equals()` и `hashCode()`).

`Comparator<T>` определяет один метод:

```java
int compare(T o1, T o2);
```

Метод `compare(T o1, T o2)` принимает два объекта типа `T` и возвращает целое число:

- Если `o1` меньше `o2`, метод должен вернуть отрицательное число.
- Если `o1` больше `o2`, метод должен вернуть положительное число.
- Если `o1` равен `o2`, метод должен вернуть ноль.

Возвращаемое значение этого метода указывает на порядок сравниваемых объектов. При использовании этого интерфейса можно определить различные способы сортировки объектов, которые не основаны на их естественном порядке или реализации метода `equals()`.

`Comparator<T>` часто используется с методами сортировки, такими как `Collections.sort()` или `Arrays.sort()`, чтобы указать пользовательскую логику сравнения элементов коллекции. Он позволяет программисту контролировать порядок сортировки объектов в соответствии с определенными правилами или критериями.

Пример использования `Comparator<T>` для сортировки списка объектов по определенному полю:

```java
public class Person {
    private String name;
    private int age;

    // конструктор, геттеры и сеттеры

    // ... 

    // Comparator для сравнения объектов Person по возрасту
    public static Comparator<Person> ageComparator = new Comparator<Person>() {
        @Override
        public int compare(Person p1, Person p2) {
            return p1.getAge() - p2.getAge();
        }
    };
}
```

Затем можно отсортировать список объектов `Person` по возрасту с помощью `Collections.sort()`:

```java
List<Person> people = new ArrayList<>();
// добавление объектов в список

Collections.sort(people, Person.ageComparator);
```

Таким образом, `Comparator<T>` позволяет создавать пользовательские правила сравнения объектов и дает большую гибкость при работе с сортировкой и сравнением элементов в Java.

[к оглавлению](#функциональные-интерфейсы)

## Как создать собственный функциональный интерфейс?
Для создания собственного функционального интерфейса в Java необходимо определить интерфейс с единственным абстрактным методом (такой метод называется "абстрактным функциональным методом"). Этот интерфейс также должен быть аннотирован аннотацией `@FunctionalInterface`.

Важно, чтобы в вашем собственном функциональном интерфейсе был только один абстрактный метод, иначе компилятор не сможет однозначно понять, какой метод должен быть вызван в контексте использования лямбда-выражений.

Пример создания собственного функционального интерфейса:

```java
@FunctionalInterface
public interface MyFunctionalInterface {
    void doSomething(); // Абстрактный функциональный метод

    // Не абстрактные методы также допустимы в функциональных интерфейсах
    default void doSomethingElse() {
        System.out.println("Doing something else!");
    }
}
```

В приведенном примере `MyFunctionalInterface` является собственным функциональным интерфейсом. Он содержит один абстрактный метод `doSomething()` без параметров и не возвращает значения.

Заметьте, что интерфейс также содержит не абстрактный метод `doSomethingElse()`, который помечен как `default`. Это возможно для функциональных интерфейсов, и такие методы могут быть реализованы по умолчанию в интерфейсе.

Теперь вы можете использовать ваш собственный функциональный интерфейс для создания лямбда-выражений или ссылок на методы, так же, как и для стандартных функциональных интерфейсов из пакета `java.util.function`. Например:

```java
public class Main {
    public static void main(String[] args) {
        MyFunctionalInterface myFunc = () -> System.out.println("Doing something!");
        myFunc.doSomething(); // Выведет "Doing something!"
    }
}
```

Создание собственных функциональных интерфейсов позволяет вам создавать более читабельный и специфичный для вашего приложения код при использовании лямбда-выражений и функционального стиля программирования в Java.

[к оглавлению](#функциональные-интерфейсы)

## Как сортировать список с применением лямбда-выражений?
Для сортировки списка с использованием лямбда-выражений в Java, вы можете воспользоваться методом `sort()` из класса `java.util.Collections` или методом `sort()` из класса `java.util.List`.

Предположим, у вас есть список объектов, которые вы хотите отсортировать. Допустим, это список строк (`List<String>`), но вы можете адаптировать примеры для списка с любыми другими объектами.

1. С помощью `Collections.sort()`:
```java
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class Main {
    public static void main(String[] args) {
        List<String> myList = new ArrayList<>();
        myList.add("banana");
        myList.add("apple");
        myList.add("orange");

        // Сортировка списка с использованием лямбда-выражения
        Collections.sort(myList, (str1, str2) -> str1.compareTo(str2));

        System.out.println(myList); // Выведет: [apple, banana, orange]
    }
}
```

2. С помощью `List.sort()`:
```java
import java.util.ArrayList;
import java.util.List;

public class Main {
    public static void main(String[] args) {
        List<String> myList = new ArrayList<>();
        myList.add("banana");
        myList.add("apple");
        myList.add("orange");

        // Сортировка списка с использованием лямбда-выражения
        myList.sort((str1, str2) -> str1.compareTo(str2));

        System.out.println(myList); // Выведет: [apple, banana, orange]
    }
}
```

В приведенных примерах лямбда-выражение `(str1, str2) -> str1.compareTo(str2)` задает порядок сортировки элементов списка. В данном случае, список сортируется в естественном порядке строк. Вы можете изменить лямбда-выражение, чтобы настроить критерии сортировки в соответствии с вашими потребностями.

[к оглавлению](#функциональные-интерфейсы)

## Можно ли называть интерфейс функциональным, если при его объявлении не была применена аннотация @FunctionalInterface?
Да, можно называть интерфейс функциональным, даже если при его объявлении не была применена аннотация @FunctionalInterface. Аннотация @FunctionalInterface необязательна для того, чтобы интерфейс был функциональным.

Интерфейс считается функциональным, если он содержит только один абстрактный метод (т.е. метод без реализации) и может иметь любое количество методов с реализацией (default-методы или static-методы). Такой абстрактный метод в интерфейсе называется "методом с функциональной сигнатурой".

Начиная с версии Java 8, была добавлена аннотация @FunctionalInterface для помощи в явном определении функциональных интерфейсов. Эта аннотация служит информационным целям и позволяет компилятору проводить дополнительные проверки на корректность функциональности интерфейса. Если интерфейс помечен аннотацией @FunctionalInterface и не соответствует требованиям функционального интерфейса, компилятор выдаст ошибку.

Однако, если интерфейс удовлетворяет условию функциональности (только один абстрактный метод), но не имеет аннотации @FunctionalInterface, он всё равно считается функциональным интерфейсом. Таким образом, применение аннотации @FunctionalInterface не обязательно, хотя она может быть полезна для документирования вашего намерения сделать интерфейс функциональным и для предотвращения случайных изменений в будущем, которые могут нарушить его функциональность.

[к оглавлению](#функциональные-интерфейсы)
