# JAVA DATABASE CONNECTIVITY
Вопросы:
- [1. Что такое JDBC? Перечислить основные классы и интерфейсы, входящие в состав JDBC, указать их назначение. Какие еще существуют технологии Java, работающие с БД?](#что-такое-jdbc-перечислить-основные-классы-и-интерфейсы-входящие-в-состав-jdbc-указать-их-назначение-какие-еще-существуют-технологии-java-работающие-с-бд)
- [2. Привести алгоритм получения соединения с базой данных, выполнения запроса и обработки результатов. Как загрузить драйвер базы данных и что он собой представляет. Какие существуют типы драйверов баз данных в JDBC? Нужно ли регистрировать драйвер БД? Если да, то как это сделать?](#привести-алгоритм-получения-соединения-с-базой-данных-выполнения-запроса-и-обработки-результатов-как-загрузить-драйвер-базы-данных-и-что-он-собой-представляет-какие-существуют-типы-драйверов-баз-данных-в-jdbc-нужно-ли-регистрировать-драйвер-бд-если-да-то-как-это-сделать)
- [3. Как правильно закрыть Connection?](#как-правильно-закрыть-connection)
- [4. Какие есть типы драйверов для соединения с СУБД?](#какие-есть-типы-драйверов-для-соединения-с-субд)
- [5. Чем отличается Statement от PreparedStatement? Где сохраняется запрос после первого вызова PreparedStatement? Будет ли тот же самый эффект, как и от PreparedStatement, если формировать запрос просто в строке и отправлять его в Statement?](#чем-отличается-statement-от-preparedstatement-где-сохраняется-запрос-после-первого-вызова-preparedstatement-будет-ли-тот-же-самый-эффект-как-и-от-preparedstatement-если-формировать-запрос-просто-в-строке-и-отправлять-его-в-statement)
- [6. Защищены ли Statement и PreparedStatement от sql-injection? Можно ли работать с несколькими объектами statement или prepared statement, полученными от одного объекта connection одновременно и может ли такое использование быть небезопасным?](#защищены-ли-statement-и-preparedstatement-от-sql-injection-можно-ли-работать-с-несколькими-объектами-statement-или-prepared-statement-полученными-от-одного-объекта-connection-одновременно-и-может-ли-такое-использование-быть-небезопасным)
- [7. Зачем нужен CallableStatement? Как выполняется вызов хранимых процедур из Java-программы? Что называется batch-командой, как выполнить batch-команду?](#зачем-нужен-callablestatement-как-выполняется-вызов-хранимых-процедур-из-java-программы-что-называется-batch-командой-как-выполнить-batch-команду)
- [8. Чем отличаются метод executeUpdate() от executeQuery()?](#чем-отличаются-метод-executeupdate-от-executequery)
- [9. Для чего JDBC использует объекты типа ResultSet?](#для-чего-jdbc-использует-объекты-типа-resultset)
- [10. Что означает прокручиваемый и непрокручиваемый, обновляемый и необновляемый ResultSet?](#что-означает-прокручиваемый-и-непрокручиваемый-обновляемый-и-необновляемый-resultset)
- [11. Как можно получить такие различные типы объектов ResultSet? Можно ли через объект ResultSet изменить значения в БД и, если да, то каким образом?](#как-можно-получить-такие-различные-типы-объектов-resultset-можно-ли-через-объект-resultset-изменить-значения-в-бд-и-если-да-то-каким-образом)
- [12. Как в объекте ResultSet вернуться в предыдущую строку? Всегда ли можно вернуться в предыдущую строку?](#как-в-объекте-resultset-вернуться-в-предыдущую-строку-всегда-ли-можно-вернуться-в-предыдущую-строку)
- [13. Как получить сгенерированный СУБД первичный ключ без выполнения дополнительного запроса к БД?](#как-получить-сгенерированный-субд-первичный-ключ-без-выполнения-дополнительного-запроса-к-бд)
- [14. Как узнать, в какие типы Java будут конвертированы при выборке sql-типы данных?](#как-узнать-в-какие-типы-java-будут-конвертированы-при-выборке-sql-типы-данных)
- [15. Привести определение транзакции, commit и rollback. Как JDBC работает с транзакциями по умолчанию? Как отменить autocommit, как в этом случае следует работать с БД?](#привести-определение-транзакции-commit-и-rollback-как-jdbc-работает-с-транзакциями-по-умолчанию-как-отменить-autocommit-как-в-этом-случае-следует-работать-с-бд)
- [16. Что такое точка сохранения и как ее создать? Как откатить транзакцию до точки сохранения или до предыдущего commit?](#что-такое-точка-сохранения-и-как-ее-создать-как-откатить-транзакцию-до-точки-сохранения-или-до-предыдущего-commit)
- [17. Что такое пул соединений с БД, для чего он необходим? Каковы основные принципы создания пула соединений к БД?](#что-такое-пул-соединений-с-бд-для-чего-он-необходим-каковы-основные-принципы-создания-пула-соединений-к-бд)
- [18. Что означает термин «метаданные»? Какую информацию предоставляют объекты классов DatabaseMetaData, ResultsSetMetaData и для чего она может быть использована?](#что-означает-термин-метаданные-какую-информацию-предоставляют-объекты-классов-databasemetadata-resultssetmetadata-и-для-чего-она-может-быть-использована)
- [19. Что означает термин уровень изоляции транзакции? Какие уровни изоляции транзакций поддерживает JDBC? Как задать уровень изоляции транзакций?](#что-означает-термин-уровень-изоляции-транзакции-какие-уровни-изоляции-транзакций-поддерживает-jdbc-как-задать-уровень-изоляции-транзакций)

## Что такое JDBC? Перечислить основные классы и интерфейсы, входящие в состав JDBC, указать их назначение. Какие еще существуют технологии Java, работающие с БД?
JDBC (Java Database Connectivity) - это стандартный интерфейс для взаимодействия Java-приложений с базами данных. Он предоставляет набор классов и интерфейсов, позволяющих выполнять операции с базами данных, такие как создание подключения, выполнение SQL-запросов, обработка результатов запросов и управление транзакциями.

Основные классы и интерфейсы, входящие в состав JDBC, включают:

1. `DriverManager`: Класс для управления набором зарегистрированных драйверов JDBC. Он предоставляет методы для получения соединения с базой данных.

2. `Connection`: Интерфейс, представляющий соединение с базой данных. Он используется для создания объектов `Statement` и управления транзакциями.

3. `Statement` и `PreparedStatement`: Интерфейсы для выполнения SQL-запросов к базе данных. `PreparedStatement` представляет подготовленный SQL-запрос, который может содержать параметры.

4. `ResultSet`: Интерфейс для представления результирующего набора из выполненного SQL-запроса. Он позволяет получать данные из результирующего набора.

5. `CallableStatement`: Интерфейс для вызова хранимых процедур базы данных.

Другие технологии Java, работающие с базами данных, включают:

- Java Persistence API (JPA): Это стандартный фреймворк для управления объектно-реляционным отображением (ORM). Он позволяет работать с объектами Java как с записями в базе данных, обеспечивая автоматическое отображение между объектами и таблицами.

- Hibernate: Это одна из реализаций JPA и более широкий ORM-фреймворк. Он предоставляет мощные возможности для работы с базами данных и объектами.

- MyBatis: Это фреймворк для объектно-реляционного отображения, который позволяет определить SQL-запросы и их параметры в отдельных XML-файлах.

- Spring JDBC: Фреймворк Spring предоставляет собой удобные средства для работы с базами данных, включая автоматическую обработку исключений, управление транзакциями и упрощенный доступ к данным.
- 
[к оглавлению](#java-database-connectivity)

## Привести алгоритм получения соединения с базой данных, выполнения запроса и обработки результатов. Как загрузить драйвер базы данных и что он собой представляет. Какие существуют типы драйверов баз данных в JDBC? Нужно ли регистрировать драйвер БД? Если да, то как это сделать?
Вот пример алгоритма получения соединения с базой данных, выполнения запроса и обработки результатов с использованием JDBC:

1. Загрузите драйвер базы данных:
```java
Class.forName("com.mysql.jdbc.Driver"); // Загрузка драйвера MySQL (пример)
```

2. Получите соединение с базой данных:
```java
String url = "jdbc:mysql://localhost:3306/mydb"; // URL подключения к базе данных
String username = "user";
String password = "password";
Connection connection = DriverManager.getConnection(url, username, password);
```

3. Создайте объект Statement для выполнения SQL-запросов
4. 
```java
Statement statement = connection.createStatement();
```

4. Выполните SQL-запрос:
```java
String sqlQuery = "SELECT * FROM employees";
ResultSet resultSet = statement.executeQuery(sqlQuery);
```

5. Обработайте результаты запроса:
```java
while (resultSet.next()) {
    int id = resultSet.getInt("id");
    String name = resultSet.getString("name");
    // ... другие поля
    System.out.println("ID: " + id + ", Name: " + name);
}
```

6. Закройте ресурсы (в обратном порядке):
```java
resultSet.close();
statement.close();
connection.close();
```

Теперь по поводу драйверов баз данных в JDBC:

Драйвер базы данных представляет собой набор классов и методов, которые обеспечивают взаимодействие между Java-приложением и конкретной базой данных. Он реализует спецификацию JDBC и обеспечивает функции для установления соединения с базой данных, выполнения SQL-запросов и обработки результатов.

Существуют четыре типа драйверов баз данных в JDBC:

1. **Тип 1 - JDBC-ODBC мост**: Этот тип драйвера использует ODBC (Open Database Connectivity) для связи с базами данных. Он является устаревшим и редко используется.

2. **Тип 2 - Native-API драйвер**: Этот тип драйвера переводит вызовы JDBC-методов в вызовы нативных API конкретной базы данных. Он требует наличие нативных библиотек на стороне клиента.

3. **Тип 3 - Network Protocol драйвер**: Этот тип драйвера использует сетевой протокол для взаимодействия с сервером базы данных. Он часто называется "middleware" драйвером.

4. **Тип 4 - Thin драйвер**: Этот тип драйвера является чистым Java-драйвером, который взаимодействует непосредственно с базой данных через сетевой протокол. Он наиболее распространен и рекомендуется для использования.

Для загрузки драйвера базы данных в JDBC, можно использовать метод `Class.forName()`, как показано в первом шаге алгоритма выше. Этот метод загружает класс драйвера в память и регистрирует его в `DriverManager`. Обычно регистрация драйвера выполняется автоматически при загрузке класса.
[к оглавлению](#java-database-connectivity)

## Как правильно закрыть Connection?
Закрытие объекта `Connection` в JDBC очень важно для правильного управления ресурсами и предотвращения утечек памяти. Для закрытия соединения с базой данных следует следовать следующей практике:

1. Закройте `ResultSet`: Если у вас есть открытый `ResultSet`, убедитесь, что он закрыт перед закрытием объекта `Connection`. Также следует закрыть `Statement` или `PreparedStatement`, если такие объекты были созданы.

2. Закройте `Statement` и `PreparedStatement`: Все открытые объекты `Statement` и `PreparedStatement` должны быть закрыты перед закрытием объекта `Connection`.

3. Закройте `Connection`: Закройте сам объект `Connection` вызовом метода `close()`.

Пример закрытия `Connection` с учетом вышеуказанных шагов:

```java
Connection connection = null;
Statement statement = null;
ResultSet resultSet = null;

try {
    // Создание соединения, выполнение запросов и получение результатов
    // ...

} catch (SQLException e) {
    e.printStackTrace();
} finally {
    // Закрытие ресурсов в обратном порядке
    if (resultSet != null) {
        try {
            resultSet.close();
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    if (statement != null) {
        try {
            statement.close();
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    if (connection != null) {
        try {
            connection.close();
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
}
```

Важно отметить, что метод `close()` может вызывать исключение `SQLException`, поэтому его вызов должен быть заключен в блок `try-catch`. Использование блока `try-catch` также обеспечит правильное закрытие ресурсов даже в случае возникновения исключений.

[к оглавлению](#java-database-connectivity)

## Какие есть типы драйверов для соединения с СУБД?
Существует четыре основных типа драйверов JDBC для соединения с СУБД:

1. **JDBC-ODBC мост (JDBC-ODBC Bridge Driver):**
   Этот драйвер использует ODBC (Open Database Connectivity) для связи с базой данных. Он использует прослойку ODBC для взаимодействия с различными СУБД. Но этот драйвер устарел и не рекомендуется к использованию.

2. **Нативные драйверы (Native Drivers):**
   Эти драйверы напрямую связаны с конкретной СУБД и обычно предоставляют лучшую производительность. Каждый нативный драйвер специфичен для определенной СУБД. Примеры таких драйверов включают Oracle JDBC Driver, MySQL Connector/J и драйверы для Microsoft SQL Server.

3. **Сетевые протокольные драйверы (Network Protocol Drivers):**
   Эти драйверы используют сетевые протоколы, такие как TCP/IP, для связи с базой данных. Они также специфичны для каждой СУБД и обычно обеспечивают хорошую производительность. Примеры включают PostgreSQL JDBC Driver и DB2 JDBC Driver.

4. **Тип 4 драйверы (Thin Drivers или Direct to Database Drivers):**
   Эти драйверы также называются драйверами-чистыми Java (pure Java drivers). Они напрямую взаимодействуют с базой данных через протоколы, такие как TCP/IP. Они не требуют промежуточных слоев и обеспечивают хорошую производительность и портативность. Примеры включают Oracle Thin Driver и Microsoft SQL Server JDBC Driver.

Каждый тип драйвера имеет свои преимущества и недостатки, и выбор драйвера будет зависеть от конкретных требований вашего проекта и СУБД, с которой вы работаете.

[к оглавлению](#java-database-connectivity)

## Чем отличается Statement от PreparedStatement? Где сохраняется запрос после первого вызова PreparedStatement? Будет ли тот же самый эффект, как и от PreparedStatement, если формировать запрос просто в строке и отправлять его в Statement?
`Statement` и `PreparedStatement` - это два основных способа выполнения SQL-запросов в Java через JDBC. Они имеют схожий функционал, но есть важные различия:

1. **Statement:**
    - `Statement` используется для выполнения статических SQL-запросов, которые могут содержать фиксированный текст SQL.
    - SQL-запрос формируется непосредственно в строке кода.
    - Каждый раз, когда выполняется `Statement`, SQL-запрос интерпретируется и компилируется заново, что может повлиять на производительность при многократном выполнении одного и того же запроса.

2. **PreparedStatement:**
    - `PreparedStatement` предназначен для выполнения параметризованных SQL-запросов. Он позволяет создать SQL-запрос с заполнителями (placeholder), и значения для заполнителей устанавливаются позже.
    - При первом выполнении `PreparedStatement` SQL-запрос компилируется и оптимизируется базой данных. Затем скомпилированный запрос сохраняется в пуле, что позволяет повторно использовать его для последующих выполнений с разными значениями заполнителей.
    - Такое кеширование и повторное использование скомпилированных запросов делает `PreparedStatement` более производительным, особенно если один и тот же запрос выполняется многократно с разными значениями.

Следует отметить, что помимо преимуществ `PreparedStatement`, его также следует использовать для предотвращения SQL-инъекций, так как значения параметров автоматически обрабатываются как данные, а не как часть SQL-запроса.

[к оглавлению](#java-database-connectivity)

## Защищены ли Statement и PreparedStatement от sql-injection? Можно ли работать с несколькими объектами statement или prepared statement, полученными от одного объекта connection одновременно и может ли такое использование быть небезопасным?
`PreparedStatement` предоставляет встроенную защиту от SQL-инъекций. Он автоматически обрабатывает переданные параметры как данные, а не как часть SQL-запроса, что делает вставку вредоносных данных более сложной.

С другой стороны, `Statement` не предоставляет такой защиты, и если вы вставляете данные напрямую в SQL-запрос, это может сделать ваше приложение уязвимым для SQL-инъекций.

Относительно использования нескольких объектов `Statement` или `PreparedStatement` полученных от одного объекта `Connection`, следует знать следующее:

1. **Statement:**
    - Использование нескольких объектов `Statement` одновременно в разных потоках обычно не приводит к проблемам безопасности, так как каждый объект `Statement` управляет своим состоянием запроса.
    - Однако, использование нескольких объектов `Statement` в одном потоке для одного `Connection` может быть небезопасным, так как несколько запросов могут конкурировать за доступ к соединению.

2. **PreparedStatement:**
    - Объекты `PreparedStatement` могут безопасно использоваться одновременно в разных потоках.
    - Один объект `PreparedStatement` может использоваться многократно для выполнения запросов с разными значениями параметров.

Как правило, использование отдельного объекта `Statement` или `PreparedStatement` для каждого потока или задачи обеспечивает более надежное и безопасное выполнение запросов.

[к оглавлению](#java-database-connectivity)

## Зачем нужен CallableStatement? Как выполняется вызов хранимых процедур из Java-программы? Что называется batch-командой, как выполнить batch-команду?
`CallableStatement` предназначен для вызова хранимых процедур базы данных. Хранимые процедуры - это предварительно скомпилированные и сохраненные в базе данных наборы инструкций, которые можно вызывать из приложения. Они часто используются для выполнения сложных операций или бизнес-логики на стороне базы данных.

Вызов хранимой процедуры из Java-программы с использованием `CallableStatement` осуществляется следующим образом:

1. Подготавливается SQL-запрос, который вызывает нужную хранимую процедуру.
2. Создается объект `CallableStatement` с этим SQL-запросом.
3. Необходимые параметры устанавливаются в `CallableStatement`.
4. Вызывается метод `execute()` или `executeQuery()` объекта `CallableStatement` для выполнения хранимой процедуры.
5. При необходимости, результаты возвращаются через `ResultSet`.

"Batch-команда" представляет собой группу SQL-запросов, которые выполняются как единое действие, что может значительно улучшить производительность при работе с базой данных. Для выполнения batch-команды в JDBC, вы можете использовать методы `addBatch()` для добавления SQL-запросов в пакет, а затем вызвать `executeBatch()` для выполнения всех запросов пакета сразу.

Пример использования `CallableStatement` и batch-команды:

```java
try (Connection connection = DriverManager.getConnection(url, username, password)) {
    String sql = "{call my_stored_procedure(?, ?)}";
    CallableStatement callableStatement = connection.prepareCall(sql);
    
    callableStatement.setInt(1, param1Value);
    callableStatement.setString(2, param2Value);
    
    // Выполнение хранимой процедуры
    callableStatement.execute();

    // Создание batch-команды
    Statement batchStatement = connection.createStatement();
    batchStatement.addBatch("INSERT INTO table1 (column1) VALUES (value1)");
    batchStatement.addBatch("UPDATE table2 SET column2 = value2 WHERE condition");
    batchStatement.addBatch("DELETE FROM table3 WHERE condition");

    // Выполнение batch-команды
    int[] updateCounts = batchStatement.executeBatch();
} catch (SQLException e) {
    e.printStackTrace();
}
```

[к оглавлению](#java-database-connectivity)

## Чем отличаются метод executeUpdate() от executeQuery()?
`executeUpdate()` и `executeQuery()` - это методы из интерфейса `Statement` и его наследников в JDBC. Они используются для выполнения SQL-запросов к базе данных, но есть разница в том, какие типы запросов они поддерживают и какие результаты они возвращают:

1. **executeUpdate()**:
    - Этот метод используется для выполнения SQL-запросов, которые приводят к изменению данных в базе данных, такие как INSERT, UPDATE и DELETE.
    - Метод возвращает целое число, которое представляет количество затронутых строк в результате выполнения запроса.

Пример использования `executeUpdate()`:

```java
try (Connection connection = DriverManager.getConnection(url, username, password)) {
    String updateQuery = "UPDATE employees SET salary = salary + 1000 WHERE department = 'IT'";
    Statement statement = connection.createStatement();
    int rowsUpdated = statement.executeUpdate(updateQuery);
    System.out.println("Updated " + rowsUpdated + " rows");
} catch (SQLException e) {
    e.printStackTrace();
}
```

2. **executeQuery()**:
    - Этот метод используется для выполнения SQL-запросов, которые возвращают набор результатов, такие как SELECT.
    - Метод возвращает объект `ResultSet`, который содержит результаты запроса.

Пример использования `executeQuery()`:

```java
try (Connection connection = DriverManager.getConnection(url, username, password)) {
    String selectQuery = "SELECT * FROM employees WHERE department = 'HR'";
    Statement statement = connection.createStatement();
    ResultSet resultSet = statement.executeQuery(selectQuery);

    while (resultSet.next()) {
        int id = resultSet.getInt("id");
        String name = resultSet.getString("name");
        double salary = resultSet.getDouble("salary");
        System.out.println("Employee: " + id + ", " + name + ", " + salary);
    }
} catch (SQLException e) {
    e.printStackTrace();
}
```

Итак, `executeUpdate()` применяется для запросов, меняющих данные, и возвращает количество измененных строк, а `executeQuery()` используется для запросов, возвращающих результаты, и возвращает объект `ResultSet`.

[к оглавлению](#java-database-connectivity)

## Для чего JDBC использует объекты типа ResultSet?
Объекты типа `ResultSet` в JDBC используются для представления набора результатов, полученных в результате выполнения SQL-запроса, который возвращает данные из базы данных. `ResultSet` содержит таблицу данных, которая может быть проходной (scrollable), изменяемой (updatable) и доступной для чтения (read-only).

`ResultSet` предоставляет методы для итерации по строкам данных и извлечения значений из каждой строки. Он позволяет программе получить доступ к столбцам и значениям в текущей строке, а также перемещаться вперед, назад и к конкретной строке в наборе результатов.

Пример использования `ResultSet` для выполнения SQL-запроса `SELECT`:

```java
try (Connection connection = DriverManager.getConnection(url, username, password)) {
    String selectQuery = "SELECT id, name, salary FROM employees";
    Statement statement = connection.createStatement();
    ResultSet resultSet = statement.executeQuery(selectQuery);

    while (resultSet.next()) {
        int id = resultSet.getInt("id");
        String name = resultSet.getString("name");
        double salary = resultSet.getDouble("salary");
        System.out.println("Employee: " + id + ", " + name + ", " + salary);
    }
} catch (SQLException e) {
    e.printStackTrace();
}
```

В данном примере, через метод `next()` перемещаемся по строкам набора результатов. Затем, с помощью методов типа `getInt()`, `getString()` и `getDouble()` получаем значения из текущей строки по их названиям столбцов.

[к оглавлению](#java-database-connectivity)

## Что означает прокручиваемый и непрокручиваемый, обновляемый и необновляемый ResultSet?
`ResultSet` может быть различных типов в зависимости от того, каким образом вы можете перемещаться по набору результатов и изменять его данные. Вот некоторые из основных типов `ResultSet`:

1. **Прокручиваемый (Scrollable) ResultSet:** Прокручиваемый `ResultSet` позволяет перемещаться вперед и назад по строкам набора результатов. Вы можете использовать методы типа `absolute()`, `relative()` и `first()` для перемещения к определенной строке.

2. **Непрокручиваемый (Non-Scrollable) ResultSet:** Непрокручиваемый `ResultSet` позволяет перемещаться только вперед по строкам. Он подходит для простого прохода по набору результатов без необходимости вернуться к предыдущей строке.

3. **Обновляемый (Updatable) ResultSet:** Обновляемый `ResultSet` позволяет изменять данные в базе данных через него. Вы можете использовать методы типа `updateString()`, `updateInt()` и т.д. для обновления значений в текущей строке.

4. **Необновляемый (Read-Only) ResultSet:** Необновляемый `ResultSet` предназначен только для чтения данных и не позволяет изменять набор результатов.

Пример использования прокручиваемого и обновляемого `ResultSet`:

```java
try (Connection connection = DriverManager.getConnection(url, username, password)) {
    String selectQuery = "SELECT id, name, salary FROM employees";
    Statement statement = connection.createStatement(
        ResultSet.TYPE_SCROLL_INSENSITIVE, // Тип: прокручиваемый, но нечувствительный к изменениям
        ResultSet.CONCUR_UPDATABLE // Режим: обновляемый
    );
    ResultSet resultSet = statement.executeQuery(selectQuery);

    while (resultSet.next()) {
        int id = resultSet.getInt("id");
        String name = resultSet.getString("name");
        double salary = resultSet.getDouble("salary");
        
        // Обновление значения в текущей строке
        resultSet.updateString("name", "New Name");
        resultSet.updateRow(); // Сохранение изменений в базе данных
    }
} catch (SQLException e) {
    e.printStackTrace();
}
```

Обратите внимание, что доступность и поддержка разных типов `ResultSet` зависит от конкретной базы данных и JDBC-драйвера.

[к оглавлению](#java-database-connectivity)

## Как можно получить такие различные типы объектов ResultSet? Можно ли через объект ResultSet изменить значения в БД и, если да, то каким образом?
`ResultSet` различных типов создаются путем использования разных параметров при создании объекта `Statement`, который выполняет SQL-запрос. Вот как это делается:

1. **Прокручиваемый (Scrollable) ResultSet:**
   Для создания прокручиваемого `ResultSet` вы можете указать тип прокручиваемости, например: `ResultSet.TYPE_SCROLL_INSENSITIVE` или `ResultSet.TYPE_SCROLL_SENSITIVE`. Пример:

   ```java
   Statement statement = connection.createStatement(
       ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);
   ResultSet resultSet = statement.executeQuery(query);
   ```

2. **Обновляемый (Updatable) ResultSet:**
   Для создания обновляемого `ResultSet` вы можете добавить параметр `ResultSet.CONCUR_UPDATABLE` при создании `Statement`. Пример:

   ```java
   Statement statement = connection.createStatement(
       ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_UPDATABLE);
   ResultSet resultSet = statement.executeQuery(query);
   ```

Через объект `ResultSet` вы не можете непосредственно изменить значения в базе данных. Однако, при использовании обновляемого `ResultSet`, вы можете изменять значения в текущей строке объекта `ResultSet`. Для сохранения изменений в базе данных, после вызова методов обновления данных, вы должны вызвать метод `updateRow()` объекта `ResultSet`. Пример:

```java
while (resultSet.next()) {
    double newSalary = resultSet.getDouble("salary") * 1.1;
    resultSet.updateDouble("salary", newSalary); // Изменение значения в текущей строке
    resultSet.updateRow(); // Сохранение изменений в базе данных
}
```

Обратите внимание, что не все базы данных и драйверы поддерживают обновляемые `ResultSet`. Это зависит от конкретной реализации JDBC и возможностей базы данных.

[к оглавлению](#java-database-connectivity)

## Как в объекте ResultSet вернуться в предыдущую строку? Всегда ли можно вернуться в предыдущую строку?
В объекте `ResultSet` для возврата к предыдущей строке используется метод `previous()`. Однако не все `ResultSet` могут поддерживать операцию возврата к предыдущей строке.

Следует учитывать, что некоторые типы `ResultSet` и способы запросов могут не поддерживать возврат к предыдущей строке. Например:

1. **Forward-Only ResultSet:** При использовании прямого (`ResultSet.TYPE_FORWARD_ONLY`) ResultSet, вы не можете использовать метод `previous()` для перемещения к предыдущей строке. Этот тип ResultSet поддерживает только последовательное перемещение вперед.

2. **Типы прокручиваемых ResultSet:** Не все типы прокручиваемых ResultSet поддерживают перемещение назад. Например, `ResultSet.TYPE_FORWARD_ONLY` и `ResultSet.TYPE_SCROLL_SENSITIVE` могут не поддерживать `previous()`. Возможности будут зависеть от используемого драйвера и базы данных.

3. **Scrollable, Updatable ResultSet:** Если используется прокручиваемый и обновляемый `ResultSet` (`ResultSet.TYPE_SCROLL_INSENSITIVE` или `ResultSet.TYPE_SCROLL_SENSITIVE` с `ResultSet.CONCUR_UPDATABLE`), то `previous()` может использоваться для перемещения назад.

Прежде чем использовать метод `previous()`, убедитесь, что ваш тип `ResultSet` поддерживает эту операцию, иначе это может привести к `SQLException` или к некорректным результатам.

[к оглавлению](#java-database-connectivity)

## Как получить сгенерированный СУБД первичный ключ без выполнения дополнительного запроса к БД?
Для получения сгенерированного первичного ключа без выполнения дополнительного запроса к базе данных в JDBC, можно использовать метод `getGeneratedKeys()` объекта `PreparedStatement`. Этот метод возвращает `ResultSet`, содержащий сгенерированные ключи.

Пример использования:

```java
// Подготовить SQL запрос с указанием, что нужно получить сгенерированные ключи
String sql = "INSERT INTO table_name (column1, column2) VALUES (?, ?)";
PreparedStatement preparedStatement = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);

// Установить значения параметров запроса
preparedStatement.setString(1, value1);
preparedStatement.setString(2, value2);

// Выполнить запрос
preparedStatement.executeUpdate();

// Получить ResultSet с сгенерированными ключами
ResultSet generatedKeys = preparedStatement.getGeneratedKeys();

// Если есть сгенерированные ключи, извлечь их
if (generatedKeys.next()) {
    long primaryKey = generatedKeys.getLong(1); // Передайте индекс столбца, где хранится первичный ключ
    // Используйте полученный primaryKey
} else {
    // Сгенерированные ключи отсутствуют
}
```

Обратите внимание, что доступность и поддержка сгенерированных ключей зависит от СУБД и используемого драйвера JDBC. Не все СУБД и драйверы могут поддерживать эту функцию.

[к оглавлению](#java-database-connectivity)

## Как узнать, в какие типы Java будут конвертированы при выборке sql-типы данных?
Для того чтобы узнать, какие типы Java будут использованы при выборке определенных типов данных из SQL базы данных, вы можете обратиться к документации вашего конкретного драйвера JDBC и базы данных. Различные СУБД и драйверы JDBC могут иметь некоторые различия в том, как они маппят SQL типы данных на Java типы.

Однако, есть общие соответствия, которые обычно используются:

- **VARCHAR** или **CHAR**: обычно маппятся на Java тип `String`.
- **INTEGER**, **BIGINT**: маппятся на Java типы `int` и `long` соответственно.
- **FLOAT**, **DOUBLE**: маппятся на Java типы `float` и `double` соответственно.
- **DATE**, **TIME**, **TIMESTAMP**: маппятся на Java типы `java.sql.Date`, `java.sql.Time` и `java.sql.Timestamp`.

Но опять же, это может отличаться в зависимости от конкретного драйвера и СУБД. Если у вас есть конкретные типы данных и СУБД, с которыми вы работаете, лучше всего обратиться к официальной документации драйвера JDBC и документации СУБД для получения точной информации о соответствии типов данных.

[к оглавлению](#java-database-connectivity)

## Привести определение транзакции, commit и rollback. Как JDBC работает с транзакциями по умолчанию? Как отменить autocommit, как в этом случае следует работать с БД?
**Транзакция** - это группа операций, выполняющихся как единое целое. В контексте баз данных, транзакция обозначает последовательность SQL операций (например, вставки, обновления, удаления), которые либо полностью выполняются успешно и сохраняются в базе данных (с помощью команды `COMMIT`), либо отменяются (с помощью команды `ROLLBACK`), если произошла ошибка или не выполнены какие-либо условия.

**COMMIT** - это операция, которая подтверждает, что все изменения, внесенные в базу данных в рамках текущей транзакции, должны быть постоянно сохранены.

**ROLLBACK** - это операция, которая отменяет все изменения, внесенные в базу данных в рамках текущей транзакции, и восстанавливает базу данных к состоянию до начала транзакции.

В JDBC, по умолчанию каждая SQL операция считается транзакцией, и **автоматически подтверждается (commit)** после ее выполнения. Это состояние называется **автокоммитом** (autocommit). Если вы хотите использовать **ручное управление транзакциями**, вы можете отключить автокоммит, вызвав метод `setAutoCommit(false)` на объекте `Connection`. Это позволит вам явно начинать, завершать и отменять транзакции с помощью методов `commit()` и `rollback()`.

Пример:

```java
try {
    connection.setAutoCommit(false); // Отключаем автокоммит
    // Выполняем SQL операции
    statement.executeUpdate("INSERT INTO my_table (column1, column2) VALUES (value1, value2)");
    statement.executeUpdate("UPDATE another_table SET column3 = value3 WHERE column4 = value4");
    
    connection.commit(); // Подтверждаем транзакцию
} catch (SQLException e) {
    connection.rollback(); // Отменяем транзакцию в случае ошибки
    e.printStackTrace();
} finally {
    connection.setAutoCommit(true); // Включаем автокоммит обратно
}
```

Таким образом, вы можете контролировать состояние транзакций вручную и обеспечивать более надежное управление базой данных.

[к оглавлению](#java-database-connectivity)

## Что такое точка сохранения и как ее создать? Как откатить транзакцию до точки сохранения или до предыдущего commit?
**Точка сохранения** (Savepoint) - это метка внутри транзакции, которая позволяет вам откатиться к определенному состоянию транзакции без отката всей транзакции. Точки сохранения полезны, когда вы хотите сохранить часть изменений в транзакции, но возможно, нужно будет откатиться к более раннему состоянию в случае ошибки.

Чтобы создать точку сохранения, вы можете использовать метод `setSavepoint()` объекта `Connection`:

```java
Savepoint savepoint = connection.setSavepoint("mySavepoint");
```

Здесь `"mySavepoint"` - это имя точки сохранения.

После создания точки сохранения, вы можете выполнять операции, и если что-то идет не так, вы можете откатиться к этой точке сохранения с помощью метода `rollback(Savepoint savepoint)`:

```java
try {
    // Выполняем SQL операции
    statement.executeUpdate("INSERT INTO my_table (column1, column2) VALUES (value1, value2)");
    Savepoint savepoint = connection.setSavepoint("mySavepoint");
    statement.executeUpdate("UPDATE another_table SET column3 = value3 WHERE column4 = value4");
    
    // В случае ошибки, откатываемся до точки сохранения
    connection.rollback(savepoint);
} catch (SQLException e) {
    e.printStackTrace();
}
```

Если вы хотите откатить всю транзакцию до начала, вы можете использовать метод `rollback()` без аргументов:

```java
try {
    // Выполняем SQL операции
    statement.executeUpdate("INSERT INTO my_table (column1, column2) VALUES (value1, value2)");
    
    // В случае ошибки, откатываем всю транзакцию
    connection.rollback();
} catch (SQLException e) {
    e.printStackTrace();
}
```

Таким образом, точки сохранения позволяют более гибко управлять состоянием транзакции и откатывать только часть изменений, если это необходимо.

[к оглавлению](#java-database-connectivity)

## Что такое пул соединений с БД, для чего он необходим? Каковы основные принципы создания пула соединений к БД?
Пул соединений с базой данных (Connection Pool) - это механизм, который позволяет управлять и предоставлять заранее созданные и готовые к использованию соединения с базой данных. Он помогает избежать избыточного создания и закрытия соединений с БД, что может быть затратным по времени и ресурсам.

Основная цель пула соединений состоит в том, чтобы повторно использовать уже существующие соединения вместо создания новых каждый раз, когда приложение требует доступ к базе данных. Это улучшает производительность, уменьшает нагрузку на базу данных и снижает задержку, связанную с созданием соединений.

Принципы создания пула соединений:

1. **Инициализация пула:** При старте приложения создаются начальные соединения и помещаются в пул.

2. **Запрос соединения:** Когда приложение нуждается в доступе к базе данных, оно запрашивает соединение из пула.

3. **Использование соединения:** Приложение использует соединение для выполнения запросов к базе данных.

4. **Освобождение соединения:** После завершения использования соединение возвращается обратно в пул вместо закрытия.

5. **Переиспользование:** Пул управляет жизненным циклом соединений, предоставляя их для следующих запросов.

6. **Управление нагрузкой:** Пул может управлять количеством активных соединений, чтобы избежать перегрузки базы данных.

7. **Обработка исключений:** Пул должен уметь обрабатывать исключения, связанные с соединениями, например, если соединение было разорвано.

Интеграция пула соединений упрощает управление соединениями, снижает нагрузку на базу данных и улучшает производительность вашего приложения. Различные библиотеки, такие как Apache Commons DBCP, HikariCP и другие, предоставляют реализации пула соединений для различных баз данных и платформ.

[к оглавлению](#java-database-connectivity)

## Что означает термин «метаданные»? Какую информацию предоставляют объекты классов DatabaseMetaData, ResultsSetMetaData и для чего она может быть использована?
Термин "метаданные" (metadata) относится к данным, которые описывают другие данные. В контексте баз данных метаданные содержат информацию о структуре, характеристиках и свойствах самих данных и компонентов базы данных, таких как таблицы, столбцы, индексы и другие объекты.

В Java для работы с метаданными базы данных существуют следующие классы:

1. **DatabaseMetaData:** Этот интерфейс предоставляет методы для получения метаданных о базе данных, такие как информация о её версии, названии, поддерживаемых функциях, ограничениях, характеристиках и других свойствах. Это позволяет приложению адаптироваться к конкретной базе данных и выполнять динамический код на основе её характеристик.

2. **ResultSetMetaData:** Этот интерфейс предоставляет методы для получения метаданных о структуре результатов SQL-запроса, выполненного на базе данных. Например, вы можете узнать количество столбцов, их типы данных, названия столбцов и другую информацию о результирующем наборе данных. Это полезно, когда вы хотите динамически обрабатывать результаты запросов.

Информация, предоставляемая этими классами, может быть использована для следующих целей:

- **Динамическая генерация SQL-запросов:** Например, вы можете динамически создавать запросы, основываясь на названиях таблиц и столбцов, полученных из метаданных.

- **Создание адаптивных приложений:** Зная характеристики базы данных, вы можете адаптировать своё приложение для работы с разными типами баз данных.

- **Обработка результатов запросов:** С метаданными о результирующем наборе данных можно эффективно обрабатывать полученные данные, динамически создавая структуры для их обработки.

- **Оптимизация производительности:** Метаданные могут использоваться для оптимизации выполнения запросов, так как они позволяют определить оптимальные стратегии доступа к данным.

В целом, метаданные в JDBC позволяют более гибко и адаптивно работать с базой данных, учитывая её специфические характеристики.

[к оглавлению](#java-database-connectivity)

## Что означает термин уровень изоляции транзакции? Какие уровни изоляции транзакций поддерживает JDBC? Как задать уровень изоляции транзакций?
Уровень изоляции транзакции определяет, как транзакция видит изменения, внесенные другими транзакциями в базе данных. Уровень изоляции определяет степень, до которой изменения, внесенные одной транзакцией, будут видны другим транзакциям.

JDBC поддерживает четыре уровня изоляции транзакций, которые соответствуют стандартам ANSI SQL:

1. **TRANSACTION_READ_UNCOMMITTED:** Это самый низкий уровень изоляции. Транзакция на этом уровне видит изменения, внесенные другими транзакциями, даже если они не были закоммичены. Это может привести к "грязным чтениям" и другим проблемам согласованности данных.

2. **TRANSACTION_READ_COMMITTED:** Это более строгий уровень изоляции. Транзакция видит только те изменения, которые были закоммичены другими транзакциями. Это предотвращает "грязные чтения", но может привести к "неповторяющимся чтениям" и "фантомным чтениям".

3. **TRANSACTION_REPEATABLE_READ:** Этот уровень изоляции предотвращает "неповторяющиеся чтения", но не гарантирует отсутствие "фантомных чтений". Транзакция видит только те изменения, которые были закоммичены другими транзакциями на момент начала текущей транзакции.

4. **TRANSACTION_SERIALIZABLE:** Это самый строгий уровень изоляции. Он гарантирует отсутствие "грязных чтений", "неповторяющихся чтений" и "фантомных чтений". Все операции чтения и записи блокируются для других транзакций до завершения текущей транзакции.

Уровень изоляции транзакции можно задать при открытии соединения с базой данных с помощью метода `setTransactionIsolation()` класса `Connection`. Пример:

```java
Connection connection = DriverManager.getConnection(url, username, password);
connection.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);
```

Выбор уровня изоляции зависит от требований к согласованности данных и производительности приложения. Более высокие уровни изоляции обеспечивают большую согласованность, но могут привести к блокировкам и ухудшению производительности.

[к оглавлению](#java-database-connectivity)
