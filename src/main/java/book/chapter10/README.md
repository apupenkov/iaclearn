# ПОТОКИ ВВОДА/ВЫВОДА
Вопросы:
- [1. Что такое поток данных? Какие потоки данных существуют в Java? Привести иерархию потоков ввода-вывода в Java.](#что-такое-поток-данных-какие-потоки-данных-существуют-в-java-привести-иерархию-потоков-ввода-вывода-в-java)
- [2. Какие классы байтовых потоков ввода-вывода существуют?](#какие-классы-байтовых-потоков-ввода-вывода-существуют)
- [3. Какие классы символьных потоков ввода-вывода существуют?](#какие-классы-символьных-потоков-ввода-вывода-существуют)
- [4. Как работают методы read() и write() базовых классов иерархии символьных и байтовых потоков? Сравнить.](#как-работают-методы-read-и-write-базовых-классов-иерархии-символьных-и-байтовых-потоков-сравнить)
- [5. Для чего используются классы BufferedInputStream, BufferedOutputStream, BufferedReader, BufferedWriter?](#для-чего-используются-классы-bufferedinputstream-bufferedoutputstream-bufferedreader-bufferedwriter)
- [6. Для чего используются классы FilterInputStream, FilterOutputStream, FilterReader, FilterWriter?](#для-чего-используются-классы-filterinputstream-filteroutputstream-filterreader-filterwriter)
- [7. Для чего применяются классы InputStreamReader и OutputStreamWriter?](#для-чего-применяются-классы-inputstreamreader-и-outputstreamwriter)
- [8. Что такое упаковка (wrapping) потоков?](#что-такое-упаковка-wrapping-потоков)
- [9. Какие существуют предопределенные потоки ввода-вывода в Java? Кто эти потоки создает, и кто их закрывает?](#какие-существуют-предопределенные-потоки-ввода-вывода-в-java-кто-эти-потоки-создает-и-кто-их-закрывает)
- [10. Что такое сериализация, для чего нужна, когда применяется? Правила сериализации объектов.](#что-такое-сериализация-для-чего-нужна-когда-применяется-правила-сериализации-объектов)
- [11. Что такое десериализация? Правила десериализации объектов.](#что-такое-десериализация-правила-десериализации-объектов)
- [12. Будет ли повторно сериализоваться уже сериализованный объект?](#будет-ли-повторно-сериализоваться-уже-сериализованный-объект)
- [13. Что получится при десериализации, если при сериализации сохраняемые объекты имели ссылки на одни и те же объекты?](#что-получится-при-десериализации-если-при-сериализации-сохраняемые-объекты-имели-ссылки-на-одни-и-те-же-объекты)

## Что такое поток данных? Какие потоки данных существуют в Java? Привести иерархию потоков ввода-вывода в Java.
Поток данных в Java представляет собой абстракцию для передачи информации между программой и внешними источниками или получателями данных, такими как файлы, сетевые соединения, устройства и т.д. Потоки данных позволяют программе читать данные из источников или записывать данные в них.

В Java существует два основных вида потоков данных:

1. Потоки ввода (`InputStream`): Предназначены для чтения данных из внешних источников в программу.
2. Потоки вывода (`OutputStream`): Предназначены для записи данных из программы во внешние источники.

Иерархия потоков ввода-вывода в Java:

```
        +-- FileInputStream
        |
InputStream
        |
        +-- ByteArrayInputStream
        |
        +-- ...
        
        +-- FileOutputStream
        |
OutputStream
        |
        +-- ByteArrayOutputStream
        |
        +-- ...
```

В иерархии потоков ввода-вывода класс `InputStream` является абстрактным базовым классом для всех потоков ввода, а класс `OutputStream` - для всех потоков вывода.

Некоторые из наиболее часто используемых классов в этой иерархии:

- `FileInputStream` и `FileOutputStream`: Позволяют работать с файлами.
- `ByteArrayInputStream` и `ByteArrayOutputStream`: Работа с байтовыми массивами в памяти.
- `DataInputStream` и `DataOutputStream`: Позволяют работать с примитивными типами данных.
- `BufferedInputStream` и `BufferedOutputStream`: Добавляют буферизацию для более эффективного чтения и записи.
- `ObjectInputStream` и `ObjectOutputStream`: Позволяют сериализовать и десериализовать объекты.

Эта иерархия предоставляет разнообразные возможности для чтения и записи данных, а также обеспечивает эффективность и удобство работы с разными источниками и потребителями данных.

[к оглавлению](#потоки-ввода/вывода)

## Какие классы байтовых потоков ввода-вывода существуют?
В Java существует несколько классов байтовых потоков ввода-вывода, предназначенных для работы с байтовыми данными. Вот некоторые из них:

1. `FileInputStream` и `FileOutputStream`: Позволяют работать с файлами. `FileInputStream` читает данные из файла, а `FileOutputStream` записывает данные в файл.

2. `ByteArrayInputStream` и `ByteArrayOutputStream`: Работа с байтовыми массивами в памяти. `ByteArrayInputStream` позволяет читать данные из байтового массива, а `ByteArrayOutputStream` - записывать данные в массив.

3. `PipedInputStream` и `PipedOutputStream`: Используются для передачи данных между двумя потоками в одной программе.

4. `BufferedInputStream` и `BufferedOutputStream`: Предоставляют буферизацию для более эффективного чтения и записи. Они могут быть обернуты вокруг других байтовых потоков для улучшения производительности.

5. `DataInputStream` и `DataOutputStream`: Позволяют работать с примитивными типами данных (например, числами, строками) и записывать их в байтовый поток и читать из него.

6. `ObjectInputStream` и `ObjectOutputStream`: Позволяют сериализовать и десериализовать объекты, сохраняя их состояние.

Эти классы предоставляют различные возможности для работы с байтовыми данными в потоках ввода-вывода.

[к оглавлению](#потоки-ввода/вывода)

## Какие классы символьных потоков ввода-вывода существуют?
В Java существует несколько классов символьных потоков ввода-вывода, предназначенных для работы с символьными данными. Вот некоторые из них:

1. `FileReader` и `FileWriter`: Позволяют работать с текстовыми файлами. `FileReader` читает символы из файла, а `FileWriter` записывает символы в файл.

2. `CharArrayReader` и `CharArrayWriter`: Работа с символьными массивами в памяти. `CharArrayReader` позволяет читать символы из массива, а `CharArrayWriter` - записывать символы в массив.

3. `StringReader` и `StringWriter`: Позволяют работать со строками как с символьными потоками. `StringReader` читает символы из строки, а `StringWriter` - записывает символы в строку.

4. `BufferedReader` и `BufferedWriter`: Предоставляют буферизацию для более эффективного чтения и записи символов. Они могут быть обернуты вокруг других символьных потоков для улучшения производительности.

5. `InputStreamReader` и `OutputStreamWriter`: Позволяют преобразовывать байтовые потоки в символьные и наоборот, используя указанную кодировку.

6. `PrintWriter`: Позволяет удобно записывать форматированные данные в символьный поток.

Эти классы предоставляют различные возможности для работы с символьными данными в потоках ввода-вывода.

[к оглавлению](#потоки-ввода/вывода)

## Как работают методы read() и write() базовых классов иерархии символьных и байтовых потоков? Сравнить.
Методы `read()` и `write()` в базовых классах иерархии символьных и байтовых потоков предоставляют функциональность для чтения данных из потока (ввода) и записи данных в поток (вывода). Однако из-за разных характеристик байтовых и символьных данных, их использование и поведение немного отличаются.

**Методы `read()`**:

- **Байтовые потоки**: В байтовых потоках, метод `read()` читает очередной байт данных и возвращает его в виде целого числа (0-255). Если достигнут конец потока, метод вернет `-1`. Пример использования байтового потока чтения:
  ```java
  int data;
  while ((data = inputStream.read()) != -1) {
      // Обработка прочитанных байтов
  }
  ```

- **Символьные потоки**: В символьных потоках, метод `read()` читает очередной символ и возвращает его как `int`. Если достигнут конец потока, метод вернет `-1`. Пример использования символьного потока чтения:
  ```java
  int data;
  while ((data = reader.read()) != -1) {
      char character = (char) data; // Преобразование int в char
      // Обработка прочитанных символов
  }
  ```

**Методы `write()`**:

- **Байтовые потоки**: В байтовых потоках, метод `write(int byteValue)` записывает один байт данных (нижний байт значения `byteValue`) в поток вывода. Пример использования байтового потока записи:
  ```java
  outputStream.write(65); // Записать байт с ASCII-кодом 65 ('A')
  ```

- **Символьные потоки**: В символьных потоках, метод `write(int charValue)` записывает один символ данных (значение `charValue`) в поток вывода. Пример использования символьного потока записи:
  ```java
  writer.write('A'); // Записать символ 'A'
  ```

Как видно из примеров, байтовые потоки работают с байтами, в то время как символьные потоки работают с символами. Выбор между байтовыми и символьными потоками зависит от характера данных, с которыми вы работаете, и требований к кодировке.

[к оглавлению](#потоки-ввода/вывода)

## Для чего используются классы BufferedInputStream, BufferedOutputStream, BufferedReader, BufferedWriter?
Классы `BufferedInputStream`, `BufferedOutputStream`, `BufferedReader` и `BufferedWriter` предназначены для буферизации операций ввода-вывода, что может существенно улучшить производительность при чтении и записи данных. Они позволяют снизить количество фактических операций чтения и записи из файла или другого источника данных.

Принцип работы буферизованных потоков следующий: вместо того чтобы читать или записывать данные непосредственно из файла или другого источника, они читают или записывают данные во внутренний буфер определенного размера, а затем операции чтения или записи производятся из этого буфера.

Вот для чего используются эти классы:

- **BufferedInputStream**: Этот класс оборачивает другой входной поток данных (например, `FileInputStream`) и добавляет буферизацию. Он позволяет считывать данные из буфера более эффективно, чем непосредственно из файла. Это особенно полезно при работе с большими объемами данных.

- **BufferedOutputStream**: Этот класс аналогичен `BufferedInputStream`, но для операций записи данных. Он буферизует данные, которые вы записываете, и отправляет их на запись в выходной поток пачками, что может уменьшить количество операций записи.

- **BufferedReader**: Этот класс обеспечивает буферизированное чтение текстовых данных. Он позволяет считывать строки текста из буфера в более оптимизированном режиме, а также предоставляет методы для удобного чтения.

- **BufferedWriter**: Этот класс аналогичен `BufferedReader`, но для операций записи текстовых данных. Он буферизует текст, который вы записываете, и отправляет его на запись в выходной поток пачками.

Использование буферизованных потоков может значительно улучшить производительность при операциях ввода-вывода, особенно при работе с файлами или другими медленными источниками данных.

[к оглавлению](#потоки-ввода/вывода)

## Для чего используются классы FilterInputStream, FilterOutputStream, FilterReader, FilterWriter?
Классы `FilterInputStream`, `FilterOutputStream`, `FilterReader` и `FilterWriter` являются частями иерархии потоков ввода-вывода в Java и используются для добавления дополнительных функциональных возможностей к существующим потокам. Они называются "фильтровыми" потоками, так как они фильтруют или изменяют данные, которые проходят через них, перед тем как данные будут переданы дальше по цепочке потоков.

Вот для чего используются эти классы:

- **FilterInputStream**: Этот класс предоставляет базовую реализацию для создания фильтров для байтовых потоков ввода. Он может быть расширен для создания специализированных фильтров, которые могут выполнять дополнительные операции над данными, читаемыми из потока.

- **FilterOutputStream**: Аналогично `FilterInputStream`, этот класс предоставляет базовую реализацию для создания фильтров для байтовых потоков вывода. Фильтры могут изменять, обрабатывать или дополнять данные перед записью в выходной поток.

- **FilterReader**: Этот класс предоставляет базовую реализацию для создания фильтров для символьных потоков ввода. Фильтры могут изменять, обрабатывать или дополнять символы перед их чтением из потока.

- **FilterWriter**: Аналогично `FilterReader`, этот класс предоставляет базовую реализацию для создания фильтров для символьных потоков вывода. Фильтры могут изменять, обрабатывать или дополнять символы перед их записью в выходной поток.

Фильтровые потоки особенно полезны при реализации функциональности, которая должна быть добавлена поверх существующих потоков ввода-вывода, например, шифрование, сжатие, буферизация и другие операции. Путем расширения и доработки фильтров можно легко внедрять дополнительные возможности без изменения существующего кода, который работает с базовыми потоками.

[к оглавлению](#потоки-ввода/вывода)

## Для чего применяются классы InputStreamReader и OutputStreamWriter?
Классы `InputStreamReader` и `OutputStreamWriter` предназначены для обеспечения моста между байтовыми потоками ввода-вывода и символьными потоками ввода-вывода. Они решают проблему преобразования байтов в символы и обратно, что особенно важно при работе с текстовыми данными в разных кодировках.

- **InputStreamReader**: Этот класс используется для чтения текстовых данных из байтового потока ввода. Он преобразует байты, полученные из входного потока, в символы, используя указанную кодировку. Таким образом, `InputStreamReader` позволяет читать текст из потока с учетом определенной кодировки.

- **OutputStreamWriter**: Этот класс используется для записи текстовых данных в байтовый поток вывода. Он выполняет преобразование символов в байты перед записью в выходной поток. Вы можете указать желаемую кодировку, чтобы текст был правильно преобразован в байты в соответствии с заданными требованиями.

Пример использования `InputStreamReader`:
```java
try (InputStream inputStream = new FileInputStream("file.txt");
     InputStreamReader reader = new InputStreamReader(inputStream, StandardCharsets.UTF_8)) {
    int data;
    while ((data = reader.read()) != -1) {
        System.out.print((char) data);
    }
} catch (IOException e) {
    e.printStackTrace();
}
```

Пример использования `OutputStreamWriter`:
```java
try (OutputStream outputStream = new FileOutputStream("output.txt");
     OutputStreamWriter writer = new OutputStreamWriter(outputStream, StandardCharsets.UTF_8)) {
    String text = "Hello, World!";
    writer.write(text);
} catch (IOException e) {
    e.printStackTrace();
}
```

Оба эти класса очень полезны, когда вам нужно работать с текстовыми данными, и вы хотите быть уверены, что кодировка правильно согласована между байтовыми и символьными потоками.

[к оглавлению](#потоки-ввода/вывода)

## Что такое упаковка (wrapping) потоков?
Упаковка (wrapping) потоков в Java означает оборачивание одного потока ввода-вывода другим для добавления дополнительной функциональности или изменения поведения. Это достигается путем создания объекта одного потока, который оборачивает другой поток и предоставляет дополнительные методы или функции.

Упаковка потоков полезна, когда вы хотите добавить дополнительную функциональность к уже существующим потокам, например, буферизацию, преобразование данных, сжатие и так далее.

Примеры классов для упаковки потоков в Java:

1. **BufferedInputStream / BufferedOutputStream**: Добавляют буферизацию к байтовым потокам ввода и вывода, что может улучшить производительность при чтении или записи небольших порций данных.

2. **BufferedReader / BufferedWriter**: Предоставляют буферизированный символьный поток для более эффективного чтения и записи текстовых данных.

3. **DataInputStream / DataOutputStream**: Позволяют записывать и считывать примитивные типы данных (int, double, boolean и т.д.) в двоичном формате.

4. **ObjectInputStream / ObjectOutputStream**: Позволяют сериализовать и десериализовать объекты.

5. **ZipInputStream / ZipOutputStream**: Позволяют работать с архивами формата ZIP, добавляя сжатие и архивацию к потокам.

6. **InputStreamReader / OutputStreamWriter**: Позволяют работать с потоками символов, добавляя возможность указания кодировки для чтения и записи.

7. **CipherInputStream / CipherOutputStream**: Добавляют шифрование и дешифрование к потокам для обеспечения безопасности данных.

Использование упаковки потоков позволяет гибко настраивать функциональность потоков ввода-вывода, добавляя необходимые возможности и изменения в их работе.

[к оглавлению](#потоки-ввода/вывода)

## Какие существуют предопределенные потоки ввода-вывода в Java? Кто эти потоки создает, и кто их закрывает?
В Java существует несколько предопределенных потоков ввода-вывода, которые предоставляют доступ к стандартным источникам и целевым устройствам. Эти потоки создаются автоматически и управляются JVM. Вот некоторые из предопределенных потоков ввода-вывода:

1. **System.in**: Этот поток представляет стандартный ввод, обычно связанный с клавиатурой. Он читает данные с клавиатуры, и его тип - `InputStream`. Пользователь вводит данные, и программа может их считывать через этот поток.

2. **System.out**: Этот поток представляет стандартный вывод, обычно связанный с консолью. Он позволяет программе выводить данные на экран, и его тип - `PrintStream`. Программа может отправлять данные для вывода на консоль через этот поток.

3. **System.err**: Этот поток также представляет стандартный вывод, но он используется для вывода ошибок и предупреждений. Его тип - `PrintStream`. Этот поток может быть перенаправлен для вывода ошибок в файл или другой источник.

Эти предопределенные потоки создаются автоматически при запуске программы, и их закрытие также управляется JVM. Обычно их не нужно закрывать вручную. Однако, при использовании пользовательских потоков, созданных для работы с файлами или другими ресурсами, рекомендуется закрывать их вручную после завершения работы с ресурсами. Это можно сделать с помощью методов `close()` или с использованием блока try-with-resources.

[к оглавлению](#потоки-ввода/вывода)

## Что такое сериализация, для чего нужна, когда применяется? Правила сериализации объектов.
Сериализация в Java - это процесс преобразования объекта в последовательность байтов, которая может быть сохранена в файле, передана по сети или сохранена в другом хранилище. Этот процесс позволяет сохранить состояние объекта, включая его поля и значения, в таком формате, который может быть восстановлен обратно в объект в будущем. Сериализация широко используется для сохранения состояния объектов во временных хранилищах, передачи данных между клиентом и сервером, а также для кэширования и хранения данных.

Правила сериализации объектов включают:

1. **Интерфейс `Serializable`**: Для того чтобы объект можно было сериализовать, его класс должен реализовать интерфейс `Serializable`.

2. **Поля объекта**: Только те поля объекта будут сериализованы, которые сами по себе являются сериализуемыми (их классы также должны быть помечены как `Serializable`).

3. **transient**: Если поле объекта помечено ключевым словом `transient`, то оно не будет сериализовано. Такие поля обычно используются для временных или чувствительных данных, которые не должны сохраняться.

4. **Статические поля**: Статические поля не сериализуются, так как они относятся к классу, а не к конкретному объекту.

Применение сериализации:
- Сохранение объектов в файловой системе для будущего использования.
- Передача объектов между клиентом и сервером в сетевых приложениях.
- Сохранение объектов в базах данных.
- Кэширование объектов для оптимизации производительности.

Обратите внимание, что при использовании сериализации следует учесть совместимость версий объектов, особенно если эти объекты могут быть сериализованы в файлы и восстановлены позднее.

[к оглавлению](#потоки-ввода/вывода)

## Что такое десериализация? Правила десериализации объектов.
Десериализация в Java - это процесс восстановления объекта из байтовой последовательности, полученной в результате сериализации. В других словах, десериализация позволяет восстановить объект из сохраненных данных.

Правила десериализации объектов включают:

1. **Интерфейс `Serializable`**: Класс объекта и все его родительские классы до самого верхнего класса должны реализовывать интерфейс `Serializable`.

2. **Сигнатура класса**: Если класс объекта изменил свою структуру с момента сериализации (например, добавились новые поля), десериализация может привести к `InvalidClassException`. Чтобы избежать этой проблемы, следует использовать специальные методы `serialVersionUID` для указания версии класса.

3. **Доступ к конструктору**: При десериализации объекта Java вызывает конструктор без аргументов класса (если такой конструктор есть). Если класс не имеет публичного конструктора без аргументов, то при десериализации может возникнуть исключение.

4. **transient и static**: Поля, помеченные как `transient`, будут восстановлены со значениями по умолчанию. Статические поля не десериализуются, так как они принадлежат классу, а не объекту.

5. **Уровень доступа**: Поля объекта, которые не имеют публичного или `package-private` доступа, не могут быть десериализованы, если десериализация происходит в другом пакете.

6. **Суперклассы**: Если объект является экземпляром подкласса, а сериализация была выполнена на уровне суперкласса, десериализация в суперкласс может потребовать явного приведения типа.

7. **Состояние**: Десериализация может восстановить состояние объекта, но не выполнит конструкторы и инициализаторы.

Десериализация может быть использована для восстановления объектов из файлов, сетевой передачи данных и восстановления состояния внутри приложения.

[к оглавлению](#потоки-ввода/вывода)

## Будет ли повторно сериализоваться уже сериализованный объект?
Да, если вы попытаетесь сериализовать объект, который уже был сериализован, Java будет сериализовать его снова. Сериализация - это процесс преобразования объекта в байтовую последовательность, которая может быть сохранена или передана. Каждый раз, когда вы выполняете сериализацию, будет создана новая последовательность байтов, даже если объект и его состояние остаются теми же.

Это может быть полезно, например, при создании копий объектов или при передаче объектов по сети. Каждая сериализованная копия будет содержать текущее состояние объекта на момент сериализации, а не состояние, которое могло измениться после этого.

[к оглавлению](#потоки-ввода/вывода)

## Что получится при десериализации, если при сериализации сохраняемые объекты имели ссылки на одни и те же объекты?
При десериализации объектов, которые имели ссылки на одни и те же объекты во время сериализации, будут восстановлены соответствующие ссылки. Другими словами, при десериализации будут воссозданы те же самые ссылки на объекты, что и до сериализации.

Это означает, что если у вас был объект A, который ссылался на объект B, и оба объекта были сериализованы, то при десериализации объекта A снова будет ссылка на тот же самый объект B.

Процесс десериализации сохраняет связи между объектами, если они были правильно сериализованы. Если объекты были корректно связаны в момент сериализации, то эти связи также будут сохранены и восстановлены при десериализации.

[к оглавлению](#потоки-ввода/вывода)
